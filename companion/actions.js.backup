// actions.js
const {
	SNAPSHOT_MAX,
	DISPLAY_BRIGHTNESS_CHOICES,
	DISPLAY_COLOR_CHOICES,
	rangeChoices,
	buildInputChoices,
	buildOutputChoices,
	buildSnapshotChoices,
	nn,
} = require('./helpers')

// ===================================================
// =============== CHOICE BUILDERS ===================
// ===================================================

const DISPLAY_NOCHANGE = 'nochange'

// ---- Product integration (delay integration) mapping ----
const fs = require('fs')
const path = require('path')

const normalizeSpeakerKey = (key) => {
	const normalized = String(key ?? '')
		.trim()
		.replace(/[\s-]+/g, '_')
		.replace(/[^\w]/g, '_')
		.replace(/_+/g, '_')
		.toUpperCase()

	// Special case: convert LEO_M variants to just LEO
	if (normalized === 'LEO_M' || normalized === 'LEOM') {
		return 'LEO'
	}

	return normalized
}

const canonicalizeSpeakerKey = (key) => {
	return normalizeSpeakerKey(key).replace(/_/g, '')
}

const STARTING_POINTS_SOURCE = (() => {
	try {
		const candidates = [
			path.join(__dirname, 'starting-points.json'),
			path.join(__dirname, '..', 'starting-points.json'),
		]
		const filePath = candidates.find((p) => fs.existsSync(p))
		if (!filePath) return { startingPoints: {}, categories: {} }
		const raw = JSON.parse(fs.readFileSync(filePath, 'utf8'))
		if (raw && typeof raw === 'object') {
			const payload = raw.startingPoint && typeof raw.startingPoint === 'object' ? raw.startingPoint : raw
			const categories = raw.speakerCategories && typeof raw.speakerCategories === 'object' ? raw.speakerCategories : {}
			const compensation =
				raw.mixedArrayCompensation && typeof raw.mixedArrayCompensation === 'object' ? raw.mixedArrayCompensation : {}
			const combinations =
				raw.mixedArrayCombinations && typeof raw.mixedArrayCombinations === 'object' ? raw.mixedArrayCombinations : {}
			return { startingPoints: payload || {}, categories: categories, compensation: compensation, combinations: combinations }
		}
	} catch (err) {
		console.warn?.(`Failed to load starting points: ${err?.message || err}`)
	}
	return { startingPoints: {}, categories: {}, compensation: {}, combinations: {} }
})()

const PRODUCT_INTEGRATION_RAW = [
	'1:DelayIntegrationType_OFF',
	'2:DelayIntegrationType_LEO_M_pc125',
	'3:DelayIntegrationType_LEO_M_pc100',
	'4:DelayIntegrationType_LYON_pc125',
	'5:DelayIntegrationType_LYON_pc100',
	'6:DelayIntegrationType_LYON_pc63',
	'7:DelayIntegrationType_LEOPARD_pc125',
	'8:DelayIntegrationType_LEOPARD_pc100',
	'9:DelayIntegrationType_LEOPARD_pc63',
	'10:DelayIntegrationType_MILO_pc125',
	'11:DelayIntegrationType_MICA_pc125',
	'12:DelayIntegrationType_Melodie_pc125',
	'13:DelayIntegrationType_MINA_pc125',
	'14:DelayIntegrationType_M3D_pc125',
	'15:DelayIntegrationType_M3D_pc100',
	'16:DelayIntegrationType_M2D_pc125',
	'17:DelayIntegrationType_M2D_pc100',
	'18:DelayIntegrationType_M1D_pc125',
	'19:DelayIntegrationType_M1D_pc100',
	'20:DelayIntegrationType_CQ_1_pc125',
	'21:DelayIntegrationType_CQ_1_pc100',
	'22:DelayIntegrationType_CQ_2_pc125',
	'23:DelayIntegrationType_CQ_2_pc100',
	'24:DelayIntegrationType_MSL_6_pc125',
	'25:DelayIntegrationType_MSL_4_pc125',
	'26:DelayIntegrationType_JM_1P_pc125',
	'27:DelayIntegrationType_JM_1P_pc100',
	'28:DelayIntegrationType_UPM_1P_pc125',
	'29:DelayIntegrationType_UPM_1P_pc100',
	'30:DelayIntegrationType_UPM_2P_pc125',
	'31:DelayIntegrationType_UPM_2P_pc100',
	'32:DelayIntegrationType_UPM_1XP_pc125',
	'33:DelayIntegrationType_UPM_1XP_pc100',
	'34:DelayIntegrationType_UPM_2XP_pc125',
	'35:DelayIntegrationType_UPM_2XP_pc100',
	'36:DelayIntegrationType_MM_4XP_pc125',
	'37:DelayIntegrationType_MM_4XPD_pc125',
	'38:DelayIntegrationType_UPJunior_pc125',
	'39:DelayIntegrationType_UPJunior_XP_pc125',
	'40:DelayIntegrationType_UPQ_1P_pc125',
	'41:DelayIntegrationType_UPQ_1P_pc100',
	'42:DelayIntegrationType_UPQ_2P_pc125',
	'43:DelayIntegrationType_UPQ_2P_pc100',
	'44:DelayIntegrationType_UPA_1P_pc125',
	'45:DelayIntegrationType_UPA_1P_pc100',
	'46:DelayIntegrationType_UPA_2P_pc125',
	'47:DelayIntegrationType_UPA_2P_pc100',
	'48:DelayIntegrationType_UPJ_1P_pc125',
	'49:DelayIntegrationType_UPJ_1P_pc100',
	'50:DelayIntegrationType_UPJ_1XP_pc125',
	'51:DelayIntegrationType_UPJ_1XP_pc100',
	'52:DelayIntegrationType_1100_LFC_pc125',
	'53:DelayIntegrationType_1100_LFC_pc100',
	'54:DelayIntegrationType_1100_LFC_pc63',
	'55:DelayIntegrationType_900_LFC_pc125',
	'56:DelayIntegrationType_900_LFC_pc100',
	'57:DelayIntegrationType_900_LFC_pc63',
	'58:DelayIntegrationType_700_HP_pc125',
	'59:DelayIntegrationType_700_HP_pc100',
	'60:DelayIntegrationType_M3D_Sub_pc125',
	'61:DelayIntegrationType_M3D_Sub_pc100',
	'62:DelayIntegrationType_M2D_Sub_pc125',
	'63:DelayIntegrationType_M2D_Sub_pc100',
	'64:DelayIntegrationType_M1D_Sub_pc125',
	'65:DelayIntegrationType_M1D_Sub_pc100',
	'66:DelayIntegrationType_650_P_pc125',
	'67:DelayIntegrationType_650_P_pc100',
	'68:DelayIntegrationType_600_HP_pc125',
	'69:DelayIntegrationType_600_HP_pc100',
	'70:DelayIntegrationType_500_HP_pc125',
	'71:DelayIntegrationType_500_HP_pc100',
	'72:DelayIntegrationType_USW_1P_pc125',
	'73:DelayIntegrationType_USW_1P_pc100',
	'74:DelayIntegrationType_USW_1P_pc63',
	'75:DelayIntegrationType_UMS_1P_pc125',
	'76:DelayIntegrationType_UMS_1P_pc100',
	'77:DelayIntegrationType_UMS_1XP_pc125',
	'78:DelayIntegrationType_UMS_1XP_pc100',
	'79:DelayIntegrationType_LINA_pc125',
	'80:DelayIntegrationType_LINA_pc63',
	'81:DelayIntegrationType_750_LFC_pc125',
	'82:DelayIntegrationType_750_LFC_pc100',
	'83:DelayIntegrationType_750_LFC_pc63',
	'84:DelayIntegrationType_UP_4XP_pc125',
	'85:DelayIntegrationType_UP_4XP_pc100',
	'86:DelayIntegrationType_UP_4slim_pc125',
	'87:DelayIntegrationType_UP_4slim_pc63',
	'88:DelayIntegrationType_Ashby_8C_pc125',
	'89:DelayIntegrationType_Ashby_8C_pc100',
	'90:DelayIntegrationType_Ashby_5C_pc125',
	'91:DelayIntegrationType_USW_210P_pc125',
	'92:DelayIntegrationType_USW_210P_pc100',
	'93:DelayIntegrationType_USW_210P_pc63',
	'94:DelayIntegrationType_UP_4slimWP_pc125',
	'95:DelayIntegrationType_UP_4slimWP_pc63',
	'96:DelayIntegrationType_UPQ_D1_pc125',
	'97:DelayIntegrationType_UPQ_D1_pc100',
	'98:DelayIntegrationType_UPQ_D1_pc63',
	'99:DelayIntegrationType_UPQ_D2_pc125',
	'100:DelayIntegrationType_UPQ_D2_pc100',
	'101:DelayIntegrationType_UPQ_D2_pc63',
	'102:DelayIntegrationType_UPQ_D3_pc125',
	'103:DelayIntegrationType_UPQ_D3_pc100',
	'104:DelayIntegrationType_UPQ_D3_pc63',
	'105:DelayIntegrationType_ULTRA_X40_pc125',
	'106:DelayIntegrationType_ULTRA_X40_pc100',
	'107:DelayIntegrationType_ULTRA_X40_pc63',
	'108:DelayIntegrationType_ULTRA_X42_pc125',
	'109:DelayIntegrationType_ULTRA_X42_pc100',
	'110:DelayIntegrationType_ULTRA_X42_pc63',
	'111:DelayIntegrationType_MM_10_900_LFC_pc125',
	'112:DelayIntegrationType_MM_10_900_LFC_pc100',
	'113:DelayIntegrationType_MM_10_900_LFC_pc63',
	'114:DelayIntegrationType_UPJ_1Pd_pc125',
	'115:DelayIntegrationType_UPJ_1Pd_pc100',
	'116:DelayIntegrationType_UPM_1Pd_pc125',
	'117:DelayIntegrationType_UPM_1Pd_pc100',
	'118:DelayIntegrationType_UPM_2Pd_pc125',
	'119:DelayIntegrationType_UPM_2Pd_pc100',
	'120:DelayIntegrationType_ULTRA_X20_pc125',
	'121:DelayIntegrationType_ULTRA_X20_pc100',
	'122:DelayIntegrationType_ULTRA_X20_pc63',
	'123:DelayIntegrationType_ULTRA_X20XP_pc125',
	'124:DelayIntegrationType_ULTRA_X20XP_pc100',
	'125:DelayIntegrationType_ULTRA_X20XP_pc63',
	'126:DelayIntegrationType_ULTRA_X22_pc125',
	'127:DelayIntegrationType_ULTRA_X22_pc100',
	'128:DelayIntegrationType_ULTRA_X22_pc63',
	'129:DelayIntegrationType_ULTRA_X22XP_pc125',
	'130:DelayIntegrationType_ULTRA_X22XP_pc100',
	'131:DelayIntegrationType_ULTRA_X22XP_pc63',
	'132:DelayIntegrationType_ULTRA_X23_pc125',
	'133:DelayIntegrationType_ULTRA_X23_pc100',
	'134:DelayIntegrationType_ULTRA_X23_pc63',
	'135:DelayIntegrationType_ULTRA_X23XP_pc125',
	'136:DelayIntegrationType_ULTRA_X23XP_pc100',
	'137:DelayIntegrationType_ULTRA_X23XP_pc63',
	'138:DelayIntegrationType_USW_112P_pc125',
	'139:DelayIntegrationType_USW_112P_pc100',
	'140:DelayIntegrationType_USW_112P_pc63',
	'141:DelayIntegrationType_USW_112XP_pc125',
	'142:DelayIntegrationType_USW_112XP_pc100',
	'143:DelayIntegrationType_USW_112XP_pc63',
	'144:DelayIntegrationType_X_1100C_pc125',
	'145:DelayIntegrationType_X_1100C_pc100',
	'146:DelayIntegrationType_X_1100C_pc63',
	'147:DelayIntegrationType_LF_18_pc125',
	'148:DelayIntegrationType_LF_18_pc100',
	'149:DelayIntegrationType_LF_18_pc63',
	'150:DelayIntegrationType_PANTHER_pc125',
	'151:DelayIntegrationType_PANTHER_pc100',
	'152:DelayIntegrationType_PANTHER_pc63',
	'153:DelayIntegrationType_2100_LFC_pc125',
	'154:DelayIntegrationType_2100_LFC_pc100',
	'155:DelayIntegrationType_2100_LFC_pc63',
	'156:DelayIntegrationType_ULTRA_X80_pc125',
	'157:DelayIntegrationType_ULTRA_X80_pc100',
	'158:DelayIntegrationType_ULTRA_X80_pc63',
	'159:DelayIntegrationType_ULTRA_X82_pc125',
	'160:DelayIntegrationType_ULTRA_X82_pc100',
	'161:DelayIntegrationType_ULTRA_X82_pc63',
]

const PRODUCT_INTEGRATION_DATA = (() => {
	const formatSpeakerLabel = (raw) =>
		String(raw || '')
			.replace(/_/g, ' ')
			.replace(/\s+/g, ' ')
			.trim()
	const formatPhaseLabel = (digits) => `PC${digits}`

	const speakers = new Map()
	const lookup = new Map()
	const startingPointData = new Map()

	if (STARTING_POINTS_SOURCE.startingPoints && typeof STARTING_POINTS_SOURCE.startingPoints === 'object') {
		for (const [rawKey, entries] of Object.entries(STARTING_POINTS_SOURCE.startingPoints)) {
			const normalizedKey = normalizeSpeakerKey(rawKey)
			if (!normalizedKey || !Array.isArray(entries)) continue
			const canonicalKey = canonicalizeSpeakerKey(normalizedKey)
			if (!canonicalKey) continue
			const cleaned = entries
				.map((entry, idx) => {
					if (!entry) return null
					const title = String(entry.title ?? '').trim() || `Starting point ${idx + 1}`
					const controlPoints = Array.isArray(entry.controlPoints)
						? entry.controlPoints.map((cp) => String(cp || '').trim()).filter(Boolean)
						: []
					if (controlPoints.length === 0) return null
					return { id: String(idx), title, controlPoints }
				})
				.filter(Boolean)

			if (cleaned.length > 0) {
				startingPointData.set(canonicalKey, cleaned)
			}
		}
	}

	const ensureSpeaker = (key, label) => {
		const k = normalizeSpeakerKey(key)
		const lbl = formatSpeakerLabel(label || key)
		if (!speakers.has(k)) {
			speakers.set(k, { key: k, label: lbl || k, phases: [] })
		}
		return speakers.get(k)
	}

	for (const entry of PRODUCT_INTEGRATION_RAW) {
		if (!entry) continue
		const parts = String(entry).split(':')
		if (parts.length < 2) continue
		const id = parts[0].trim()
		const rawName = parts[1].trim().replace(/^DelayIntegrationType_/, '')
		if (!id || !rawName) continue

		if (rawName === 'OFF') {
			ensureSpeaker('OFF', 'Off')
			lookup.set('OFF|', id)
			continue
		}

		const match = rawName.match(/^(.*)_pc(\d+)$/i)
		if (!match) {
			continue
		}

		const speakerKey = normalizeSpeakerKey(match[1])
		const phaseDigits = match[2]
		const speaker = ensureSpeaker(speakerKey, speakerKey)
		const phaseKey = `pc${phaseDigits}`

		if (!speaker.phases.find((p) => p.id === phaseKey)) {
			const info = {
				id: phaseKey,
				label: formatPhaseLabel(phaseDigits),
				typeId: id,
				numeric: Number(phaseDigits) || 0,
			}
			speaker.phases.push(info)
		}

		lookup.set(`${speakerKey}|${phaseKey}`, id)
	}

	if (!speakers.has('OFF')) {
		speakers.set('OFF', { key: 'OFF', label: 'Off', phases: [] })
	}

	for (const speaker of speakers.values()) {
		if (Array.isArray(speaker.phases)) {
			speaker.phases.sort((a, b) => a.numeric - b.numeric)
		}
	}

	const sorted = Array.from(speakers.values()).filter((s) => s.key !== 'OFF')
	sorted.sort((a, b) => a.label.localeCompare(b.label, 'en', { sensitivity: 'base', numeric: true }))

	const speakerChoices = [{ id: 'OFF', label: 'Off' }, ...sorted.map((s) => ({ id: s.key, label: s.label }))]

	// Create filtered speaker choices for subwoofers only
	const categories = STARTING_POINTS_SOURCE.categories || {}
	const subwooferSpeakers = sorted.filter((s) => {
		// Check category using canonical key matching
		const canonical = canonicalizeSpeakerKey(s.key)
		// Try all possible keys: label, key, and check each category key after normalization
		for (const [catKey, catValue] of Object.entries(categories)) {
			const normalizedCatKey = canonicalizeSpeakerKey(catKey)
			if (normalizedCatKey === canonical && catValue === 'subwoofer') {
				return true
			}
		}
		return false
	})
	const subwooferSpeakerChoices = [
		{ id: '', label: '-- None --' },
		...subwooferSpeakers.map((s) => ({ id: s.key, label: s.label })),
	]

	// Create filtered speaker choices for line arrays only
	const lineArraySpeakers = sorted.filter((s) => {
		const canonical = canonicalizeSpeakerKey(s.key)
		for (const [catKey, catValue] of Object.entries(categories)) {
			const normalizedCatKey = canonicalizeSpeakerKey(catKey)
			if (normalizedCatKey === canonical && catValue === 'line-array') {
				return true
			}
		}
		return false
	})
	const lineArraySpeakerChoices = [
		{ id: '', label: '-- None --' },
		...lineArraySpeakers.map((s) => ({ id: s.key, label: s.label })),
	]

	const phaseGroupMap = new Map()
	const speakerPhaseGroup = new Map()
	let phaseGroupCounter = 0
	const startingPointOptionDefs = []
	const speakerStartingPointOption = new Map()
	const speakerStartingPoints = new Map()
	let startingPointCounter = 0

	for (const speaker of speakers.values()) {
		if (speaker.key === 'OFF') continue
		const comboKey = Array.isArray(speaker.phases)
			? speaker.phases
					.map((p) => p.id)
					.sort((a, b) => a.localeCompare(b))
					.join('|')
			: ''

		let group = phaseGroupMap.get(comboKey)
		if (!group) {
			const choices = speaker.phases.map((phase) => ({ id: phase.id, label: phase.label }))
			const optionId = `phase_option_${++phaseGroupCounter}`
			group = {
				optionId,
				choices,
				defaultId: speaker.phases[0]?.id || '',
				speakers: new Set(),
			}
			phaseGroupMap.set(comboKey, group)
		}

		group.speakers.add(speaker.key)

		speakerPhaseGroup.set(speaker.key, group.optionId)
	}

	const phaseOptionDefs = Array.from(phaseGroupMap.values()).map((group) => {
		const allowedSpeakers = Array.from(group.speakers)
		const allowedListJson = JSON.stringify(allowedSpeakers)
		const isVisible = new Function(
			'options',
			`const speaker = options && options.speaker !== undefined && options.speaker !== null ? String(options.speaker) : '';
       if (!speaker || speaker === 'OFF') return false;
       return ${allowedListJson}.includes(speaker);`,
		)

		return {
			type: 'dropdown',
			id: group.optionId,
			label: 'Phase Curve',
			default: group.defaultId,
			choices: group.choices,
			isVisible,
		}
	})

	for (const speaker of speakers.values()) {
		if (speaker.key === 'OFF') continue
		const canonical = canonicalizeSpeakerKey(speaker.key)
		if (!canonical) continue
		const entries = startingPointData.get(canonical)
		if (!Array.isArray(entries) || entries.length === 0) continue

		const optionId = `starting_point_option_${++startingPointCounter}`
		const safeSpeakerJson = JSON.stringify(speaker.key)
		const choices = [
			{ id: '', label: 'Do not apply starting point' },
			...entries.map((entry) => ({ id: entry.id, label: entry.title })),
		]
		const isVisible = new Function(
			'options',
			`const speaker = options && options.speaker !== undefined && options.speaker !== null ? String(options.speaker) : '';
       return speaker === ${safeSpeakerJson};`,
		)
		startingPointOptionDefs.push({
			type: 'dropdown',
			id: optionId,
			label: 'Starting point',
			default: '',
			choices,
			isVisible,
		})
		speakerStartingPointOption.set(speaker.key, optionId)
		speakerStartingPoints.set(speaker.key, entries)
	}

	// Create gradient-specific starting point options (front and reversed)
	const gradientStartingPointOptionDefs_Front = []
	const gradientStartingPointOptionDefs_Reversed = []
	const gradientSpeakerStartingPointOption_Front = new Map()
	const gradientSpeakerStartingPointOption_Reversed = new Map()
	let gradientStartingPointCounter = 0

	// Create endfire-specific starting point options
	const endfireStartingPointOptionDefs = []
	const endfireSpeakerStartingPointOption = new Map()
	let endfireStartingPointCounter = 0

	// Create array-specific starting point options
	const arrayStartingPointOptionDefs = []
	const arraySpeakerStartingPointOption = new Map()

	// Create array_endfire-specific starting point options
	const arrayendfireStartingPointOptionDefs = []
	const arrayendfireSpeakerStartingPointOption = new Map()
	let arrayendfireStartingPointCounter = 0

	for (const speaker of speakers.values()) {
		if (speaker.key === 'OFF') continue
		const canonical = canonicalizeSpeakerKey(speaker.key)
		if (!canonical) continue
		const entries = startingPointData.get(canonical)
		if (!Array.isArray(entries) || entries.length === 0) continue

		const safeSpeakerJson = JSON.stringify(speaker.key)
		const choices = [{ id: '', label: '-- None --' }, ...entries.map((entry) => ({ id: entry.id, label: entry.title }))]

		// Gradient Front starting point option
		const frontOptionId = `gradient_sp_front_${++gradientStartingPointCounter}`
		const isVisibleFront = new Function(
			'options',
			`const mode = options && options.mode !== undefined ? String(options.mode) : '';
       const speaker = options && options.gradient_speaker !== undefined && options.gradient_speaker !== null ? String(options.gradient_speaker) : '';
       return mode === 'gradient' && speaker === ${safeSpeakerJson};`,
		)
		gradientStartingPointOptionDefs_Front.push({
			type: 'dropdown',
			id: frontOptionId,
			label: 'Starting Point Front',
			default: '',
			choices,
			isVisible: isVisibleFront,
		})
		gradientSpeakerStartingPointOption_Front.set(speaker.key, frontOptionId)

		// Gradient Reversed starting point option
		const reversedOptionId = `gradient_sp_reversed_${gradientStartingPointCounter}`
		const isVisibleReversed = new Function(
			'options',
			`const mode = options && options.mode !== undefined ? String(options.mode) : '';
       const speaker = options && options.gradient_speaker !== undefined && options.gradient_speaker !== null ? String(options.gradient_speaker) : '';
       return mode === 'gradient' && speaker === ${safeSpeakerJson};`,
		)
		gradientStartingPointOptionDefs_Reversed.push({
			type: 'dropdown',
			id: reversedOptionId,
			label: 'Starting Point Reversed',
			default: '',
			choices,
			isVisible: isVisibleReversed,
		})
		gradientSpeakerStartingPointOption_Reversed.set(speaker.key, reversedOptionId)

		// End-Fire starting point option
		const endfireOptionId = `endfire_sp_${++endfireStartingPointCounter}`
		const isVisibleEndfire = new Function(
			'options',
			`const mode = options && options.mode !== undefined ? String(options.mode) : '';
       const speaker = options && options.endfire_speaker !== undefined && options.endfire_speaker !== null ? String(options.endfire_speaker) : '';
       return mode === 'endfire' && speaker === ${safeSpeakerJson};`,
		)
		endfireStartingPointOptionDefs.push({
			type: 'dropdown',
			id: endfireOptionId,
			label: 'Starting Point',
			default: '',
			choices,
			isVisible: isVisibleEndfire,
		})
		endfireSpeakerStartingPointOption.set(speaker.key, endfireOptionId)

		// Array starting point option
		const arrayOptionId = `array_sp_${endfireStartingPointCounter}`
		const isVisibleArray = new Function(
			'options',
			`const mode = options && options.mode !== undefined ? String(options.mode) : '';
       const speaker = options && options.array_speaker !== undefined && options.array_speaker !== null ? String(options.array_speaker) : '';
       return mode === 'array' && speaker === ${safeSpeakerJson};`,
		)
		arrayStartingPointOptionDefs.push({
			type: 'dropdown',
			id: arrayOptionId,
			label: 'Starting Point',
			default: '',
			choices,
			isVisible: isVisibleArray,
		})
		arraySpeakerStartingPointOption.set(speaker.key, arrayOptionId)

		// Array End-Fire starting point option
		const arrayendfireOptionId = `arrayendfire_sp_${++arrayendfireStartingPointCounter}`
		const isVisibleArrayEndfire = new Function(
			'options',
			`const mode = options && options.mode !== undefined ? String(options.mode) : '';
       const speaker = options && options.arrayendfire_speaker !== undefined && options.arrayendfire_speaker !== null ? String(options.arrayendfire_speaker) : '';
       return mode === 'array_endfire' && speaker === ${safeSpeakerJson};`,
		)
		arrayendfireStartingPointOptionDefs.push({
			type: 'dropdown',
			id: arrayendfireOptionId,
			label: 'Starting Point',
			default: '',
			choices,
			isVisible: isVisibleArrayEndfire,
		})
		arrayendfireSpeakerStartingPointOption.set(speaker.key, arrayendfireOptionId)
	}

	return {
		speakerChoices,
		subwooferSpeakerChoices,
		lineArraySpeakerChoices,
		lookup,
		speakers,
		phaseOptionDefs,
		speakerPhaseGroup,
		startingPointOptionDefs,
		speakerStartingPointOption,
		startingPoints: speakerStartingPoints,
		gradientStartingPointOptionDefs_Front,
		gradientStartingPointOptionDefs_Reversed,
		gradientSpeakerStartingPointOption_Front,
		gradientSpeakerStartingPointOption_Reversed,
		endfireStartingPointOptionDefs,
		endfireSpeakerStartingPointOption,
		arrayStartingPointOptionDefs,
		arraySpeakerStartingPointOption,
		arrayendfireStartingPointOptionDefs,
		arrayendfireSpeakerStartingPointOption,
	}
})()

const FILTER_TYPE_CHOICES_HP = [
	{ id: '1', label: 'Butterworth 6 dB' },
	{ id: '2', label: 'Butterworth 12 dB' },
	{ id: '3', label: 'Butterworth 18 dB' },
	{ id: '4', label: 'Butterworth 24 dB' },
	// { id: '5', label: 'Butterworth 30 dB' }, // secret option (hidden)
	// { id: '6', label: 'Butterworth 36 dB' }, // secret option (hidden)
	// { id: '7', label: 'Butterworth 42 dB' }, // secret option (hidden)
	{ id: '8', label: 'Butterworth 48 dB' },
	{ id: '9', label: 'Linkwitz-Riley 12 dB' },
	{ id: '10', label: 'Linkwitz-Riley 24 dB' },
	{ id: '11', label: '2nd Order (Legacy)' },
	{ id: '12', label: 'Elliptical (Legacy)' },
]

const FILTER_TYPE_CHOICES_LP = [
	{ id: '1', label: 'Butterworth 6 dB' },
	{ id: '2', label: 'Butterworth 12 dB' },
	{ id: '3', label: 'Butterworth 18 dB' },
	{ id: '4', label: 'Butterworth 24 dB' },
	// { id: '5', label: 'Butterworth 30 dB' }, // secret option (hidden)
	// { id: '6', label: 'Butterworth 36 dB' }, // secret option (hidden)
	// { id: '7', label: 'Butterworth 42 dB' }, // secret option (hidden)
	{ id: '8', label: 'Butterworth 48 dB' },
	{ id: '9', label: 'Linkwitz-Riley 12 dB' },
	{ id: '10', label: 'Linkwitz-Riley 24 dB' },
	{ id: '11', label: 'Low Pass (Legacy)' },
]

const ALLPASS_BAND_CHOICES = [
	{ id: '1', label: 'Band 1' },
	{ id: '2', label: 'Band 2' },
	{ id: '3', label: 'Band 3' },
]

// ---- Friendly label builders (use live names) ----
function buildMatrixInputChoices(self) {
	if (!self) return [{ id: '1', label: '1' }]
	const choices = []
	for (let i = 1; i <= 32; i++) {
		const nm = self?.inputName?.[i]
		const theLabel = nm && String(nm).trim() !== '' ? `${i} - ${nm}` : `${i}`
		choices.push({ id: String(i), label: theLabel })
	}
	return choices
}

function buildMatrixOutputChoices(self, NUM_OUTPUTS) {
	if (!self) return [{ id: '1', label: '1' }]
	const choices = []
	for (let o = 1; o <= NUM_OUTPUTS; o++) {
		const nm = self?.outputName?.[o]
		const label = nm && String(nm).trim() !== '' ? `${o} - ${nm}` : `${o}`
		choices.push({ id: String(o), label })
	}
	return choices
}

function quoteSnapshotArg(text) {
	const safe = String(text ?? '')
		.replace(/\\/g, '\\\\')
		.replace(/"/g, '\\"')
		.replace(/\r?\n/g, ' ')
	return `"${safe}"`
}

function buildActiveSnapshotLabel(self) {
	let raw = self?.snapshotValues?.snapshot_active_id
	if (raw == null && typeof self?.getVariableValue === 'function') {
		raw = self.getVariableValue('snapshot_active_id')
	}
	const idMatch = String(raw ?? '').match(/\d+/)
	const id = idMatch ? Number(idMatch[0]) : null
	if (!Number.isFinite(id)) return 'Active snapshot: Unknown'

	const name = String(self?.snapshotValues?.snapshot_active_name ?? '').trim()
	const comment = String(self?.snapshotValues?.snapshot_active_comment ?? '').trim()
	const pieces = [`ID ${id}`]
	if (name) pieces.push(`Name "${name}"`)
	if (comment) pieces.push(`Comment "${comment}"`)
	return `Active snapshot: ${pieces.join(' â€” ')}`
}

// ===================================================
// =============== UTILITY HELPERS ===================
// ===================================================

function speedOfSound_mps(tempC) {
	const T = Number.isFinite(Number(tempC)) ? Number(tempC) : 20
	return 331.3 + 0.606 * T
}

function safeGetChannels(options, key, max) {
	try {
		if (!options || !options[key]) return []

		const raw = Array.isArray(options[key]) ? options[key] : [options[key]]

		return raw.map((v) => Number(v)).filter((n) => Number.isFinite(n) && n >= 1 && n <= max)
	} catch (err) {
		console.error(`Error parsing channels for ${key}:`, err)
		return []
	}
}

module.exports = function UpdateActions(self, NUM_INPUTS, NUM_OUTPUTS) {
	if (!self) {
		console.error('UpdateActions: self is required')
		return
	}
	if (!Number.isFinite(NUM_INPUTS) || NUM_INPUTS < 1) {
		console.error('UpdateActions: Invalid NUM_INPUTS')
		return
	}
	if (!Number.isFinite(NUM_OUTPUTS) || NUM_OUTPUTS < 1) {
		console.error('UpdateActions: Invalid NUM_OUTPUTS')
		return
	}

	self.snapshotValues = self.snapshotValues || {}
	self.inputName = self.inputName || {}
	self.outputName = self.outputName || {}
	self.inMute = self.inMute || {}
	self.outMute = self.outMute || {}

	const actions = {}

	const inputChoicesNum = rangeChoices(NUM_INPUTS, 'Input ')
	const outputChoicesNum = rangeChoices(NUM_OUTPUTS, 'Output ')

	const inputChoicesFriendly = buildInputChoices(self, NUM_INPUTS)
	const outputChoicesFriendly = buildOutputChoices(self, NUM_OUTPUTS)

	const productIntegrationSpeakerChoices = PRODUCT_INTEGRATION_DATA?.speakerChoices || [{ id: 'OFF', label: 'Off' }]
	const subwooferSpeakerChoices = PRODUCT_INTEGRATION_DATA?.subwooferSpeakerChoices || [{ id: '', label: '-- None --' }]
	const lineArraySpeakerChoices = PRODUCT_INTEGRATION_DATA?.lineArraySpeakerChoices || [{ id: '', label: '-- None --' }]
	const productIntegrationPhaseOptionDefs = PRODUCT_INTEGRATION_DATA?.phaseOptionDefs || []
	const productIntegrationLookup = PRODUCT_INTEGRATION_DATA?.lookup || new Map()
	const productIntegrationSpeakers = PRODUCT_INTEGRATION_DATA?.speakers || new Map()
	const productIntegrationSpeakerPhaseGroup = PRODUCT_INTEGRATION_DATA?.speakerPhaseGroup || new Map()
	const productIntegrationStartingPointOptionDefs = PRODUCT_INTEGRATION_DATA?.startingPointOptionDefs || []
	const productIntegrationSpeakerStartingPointOption = PRODUCT_INTEGRATION_DATA?.speakerStartingPointOption || new Map()
	const productIntegrationStartingPoints = PRODUCT_INTEGRATION_DATA?.startingPoints || new Map()
	const gradientStartingPointOptionDefs_Front = PRODUCT_INTEGRATION_DATA?.gradientStartingPointOptionDefs_Front || []
	const gradientStartingPointOptionDefs_Reversed =
		PRODUCT_INTEGRATION_DATA?.gradientStartingPointOptionDefs_Reversed || []
	const gradientSpeakerStartingPointOption_Front =
		PRODUCT_INTEGRATION_DATA?.gradientSpeakerStartingPointOption_Front || new Map()
	const gradientSpeakerStartingPointOption_Reversed =
		PRODUCT_INTEGRATION_DATA?.gradientSpeakerStartingPointOption_Reversed || new Map()
	const endfireStartingPointOptionDefs = PRODUCT_INTEGRATION_DATA?.endfireStartingPointOptionDefs || []
	const endfireSpeakerStartingPointOption = PRODUCT_INTEGRATION_DATA?.endfireSpeakerStartingPointOption || new Map()
	const arrayStartingPointOptionDefs = PRODUCT_INTEGRATION_DATA?.arrayStartingPointOptionDefs || []
	const arraySpeakerStartingPointOption = PRODUCT_INTEGRATION_DATA?.arraySpeakerStartingPointOption || new Map()
	const arrayendfireStartingPointOptionDefs = PRODUCT_INTEGRATION_DATA?.arrayendfireStartingPointOptionDefs || []
	const arrayendfireSpeakerStartingPointOption =
		PRODUCT_INTEGRATION_DATA?.arrayendfireSpeakerStartingPointOption || new Map()

	// Factory reset commands template (will replace {ch} with actual channel number)
	const FACTORY_RESET_COMMANDS = [
		"/processing/output/{ch}/allpass/1/band_bypass='true'",
		"/processing/output/{ch}/allpass/1/frequency='32'",
		"/processing/output/{ch}/allpass/1/q='1'",
		"/processing/output/{ch}/allpass/2/band_bypass='true'",
		"/processing/output/{ch}/allpass/2/frequency='64'",
		"/processing/output/{ch}/allpass/2/q='1'",
		"/processing/output/{ch}/allpass/3/band_bypass='true'",
		"/processing/output/{ch}/allpass/3/frequency='128'",
		"/processing/output/{ch}/allpass/3/q='1'",
		"/processing/output/{ch}/allpass/bypass='false'",
		"/processing/output/{ch}/atmospheric/bypass='true'",
		"/processing/output/{ch}/atmospheric/distance='0'",
		"/processing/output/{ch}/atmospheric/gain='10'",
		"/processing/output/{ch}/beam_control_allpass/band_bypass='true'",
		"/processing/output/{ch}/beam_control_allpass/frequency='32'",
		"/processing/output/{ch}/beam_control_allpass/q='1'",
		"/processing/output/{ch}/delay='0'",
		"/processing/output/{ch}/delay_integration/1/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/1/frequency='32'",
		"/processing/output/{ch}/delay_integration/1/q='1'",
		"/processing/output/{ch}/delay_integration/10/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/10/frequency='2048'",
		"/processing/output/{ch}/delay_integration/10/q='1'",
		"/processing/output/{ch}/delay_integration/11/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/11/frequency='2896.3'",
		"/processing/output/{ch}/delay_integration/11/q='1'",
		"/processing/output/{ch}/delay_integration/12/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/12/frequency='4096'",
		"/processing/output/{ch}/delay_integration/12/q='1'",
		"/processing/output/{ch}/delay_integration/13/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/13/frequency='5792.6'",
		"/processing/output/{ch}/delay_integration/13/q='1'",
		"/processing/output/{ch}/delay_integration/14/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/14/frequency='8192'",
		"/processing/output/{ch}/delay_integration/14/q='1'",
		"/processing/output/{ch}/delay_integration/2/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/2/frequency='64'",
		"/processing/output/{ch}/delay_integration/2/q='1'",
		"/processing/output/{ch}/delay_integration/3/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/3/frequency='128'",
		"/processing/output/{ch}/delay_integration/3/q='1'",
		"/processing/output/{ch}/delay_integration/4/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/4/frequency='256'",
		"/processing/output/{ch}/delay_integration/4/q='1'",
		"/processing/output/{ch}/delay_integration/5/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/5/frequency='362'",
		"/processing/output/{ch}/delay_integration/5/q='1'",
		"/processing/output/{ch}/delay_integration/6/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/6/frequency='512'",
		"/processing/output/{ch}/delay_integration/6/q='1'",
		"/processing/output/{ch}/delay_integration/7/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/7/frequency='724.1'",
		"/processing/output/{ch}/delay_integration/7/q='1'",
		"/processing/output/{ch}/delay_integration/8/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/8/frequency='1024'",
		"/processing/output/{ch}/delay_integration/8/q='1'",
		"/processing/output/{ch}/delay_integration/9/band_bypass='true'",
		"/processing/output/{ch}/delay_integration/9/frequency='1448.2'",
		"/processing/output/{ch}/delay_integration/9/q='1'",
		"/processing/output/{ch}/delay_integration/bypass='false'",
		"/processing/output/{ch}/delay_integration/polarity_reversal='false'",
		"/processing/output/{ch}/delay_integration/type='1'",
		"/processing/output/{ch}/delay_type='0'",
		"/processing/output/{ch}/eq/1/band_bypass='false'",
		"/processing/output/{ch}/eq/1/bandwidth='1'",
		"/processing/output/{ch}/eq/1/frequency='32'",
		"/processing/output/{ch}/eq/1/gain='0'",
		"/processing/output/{ch}/eq/10/band_bypass='false'",
		"/processing/output/{ch}/eq/10/bandwidth='1'",
		"/processing/output/{ch}/eq/10/frequency='16000'",
		"/processing/output/{ch}/eq/10/gain='0'",
		"/processing/output/{ch}/eq/2/band_bypass='false'",
		"/processing/output/{ch}/eq/2/bandwidth='1'",
		"/processing/output/{ch}/eq/2/frequency='63'",
		"/processing/output/{ch}/eq/2/gain='0'",
		"/processing/output/{ch}/eq/3/band_bypass='false'",
		"/processing/output/{ch}/eq/3/bandwidth='1'",
		"/processing/output/{ch}/eq/3/frequency='125'",
		"/processing/output/{ch}/eq/3/gain='0'",
		"/processing/output/{ch}/eq/4/band_bypass='false'",
		"/processing/output/{ch}/eq/4/bandwidth='1'",
		"/processing/output/{ch}/eq/4/frequency='250'",
		"/processing/output/{ch}/eq/4/gain='0'",
		"/processing/output/{ch}/eq/5/band_bypass='false'",
		"/processing/output/{ch}/eq/5/bandwidth='1'",
		"/processing/output/{ch}/eq/5/frequency='500'",
		"/processing/output/{ch}/eq/5/gain='0'",
		"/processing/output/{ch}/eq/6/band_bypass='false'",
		"/processing/output/{ch}/eq/6/bandwidth='1'",
		"/processing/output/{ch}/eq/6/frequency='1000'",
		"/processing/output/{ch}/eq/6/gain='0'",
		"/processing/output/{ch}/eq/7/band_bypass='false'",
		"/processing/output/{ch}/eq/7/bandwidth='1'",
		"/processing/output/{ch}/eq/7/frequency='2000'",
		"/processing/output/{ch}/eq/7/gain='0'",
		"/processing/output/{ch}/eq/8/band_bypass='false'",
		"/processing/output/{ch}/eq/8/bandwidth='1'",
		"/processing/output/{ch}/eq/8/frequency='4000'",
		"/processing/output/{ch}/eq/8/gain='0'",
		"/processing/output/{ch}/eq/9/band_bypass='false'",
		"/processing/output/{ch}/eq/9/bandwidth='1'",
		"/processing/output/{ch}/eq/9/frequency='8000'",
		"/processing/output/{ch}/eq/9/gain='0'",
		"/processing/output/{ch}/eq/bypass='false'",
		"/processing/output/{ch}/fir/bypass='true'",
		"/processing/output/{ch}/gain='0'",
		"/processing/output/{ch}/highpass/bypass='true'",
		"/processing/output/{ch}/highpass/frequency='40'",
		"/processing/output/{ch}/highpass/type='0'",
		"/processing/output/{ch}/lowpass/bypass='true'",
		"/processing/output/{ch}/lowpass/frequency='160'",
		"/processing/output/{ch}/lowpass/type='0'",
		"/processing/output/{ch}/mute='true'",
		"/processing/output/{ch}/polarity_reversal='false'",
		"/processing/output/{ch}/ushaping/1/frequency='50'",
		"/processing/output/{ch}/ushaping/1/gain='0'",
		"/processing/output/{ch}/ushaping/1/slope='2'",
		"/processing/output/{ch}/ushaping/2/frequency='200'",
		"/processing/output/{ch}/ushaping/2/gain='0'",
		"/processing/output/{ch}/ushaping/2/slope='2'",
		"/processing/output/{ch}/ushaping/3/frequency='1000'",
		"/processing/output/{ch}/ushaping/3/gain='0'",
		"/processing/output/{ch}/ushaping/3/slope='2'",
		"/processing/output/{ch}/ushaping/4/frequency='4000'",
		"/processing/output/{ch}/ushaping/4/gain='0'",
		"/processing/output/{ch}/ushaping/4/slope='2'",
		"/processing/output/{ch}/ushaping/5/gain='0'",
		"/processing/output/{ch}/ushaping/bypass='false'",
		"/processing/output/{ch}/variable_eq/bypass='true'",
		"/processing/output/{ch}/variable_eq/frequency='1000'",
		"/processing/output/{ch}/variable_eq/q='1'",
		"/processing/output/{ch}/variable_eq/type='0'",
	]

	// =========================
	// ======= ENTITY ==========
	// =========================

	actions['set_group_name'] = {
		name: 'Entity: Set Group Name',
		options: [
			{
				type: 'textinput',
				id: 'group_name',
				label: 'Group Name',
				default: '',
			},
		],
		callback: (e) => {
			if (!self) return
			const groupName = String(e.options.group_name || '')
			self._cmdSendLine(`/entity/group_name='${groupName}'`)
			self.log?.('info', `Set group name to: ${groupName}`)
		},
	}

	// =========================
	// ======= MUTES ===========
	// =========================

	actions['inputs_mute_control_multi'] = {
		name: 'Inputs: Mute',
		options: [
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Mute ON' },
					{ id: 'off', label: 'Mute OFF' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Select input(s)',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
		],
		callback: (e) => {
			if (!self) return
			const op = e.options.operation
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid input channels selected')
				return
			}
			for (const ch of chs) {
				if (op === 'on' && typeof self._setMute === 'function') self._setMute('input', ch, true)
				else if (op === 'off' && typeof self._setMute === 'function') self._setMute('input', ch, false)
				else if (typeof self._toggleMute === 'function') self._toggleMute('input', ch)
			}
		},
	}

	actions['inputs_solo'] = {
		name: 'Inputs: Solo',
		options: [
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Solo ON (unmute selected, mute others)' },
					{ id: 'off', label: 'Solo OFF (unmute all)' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input(s) to solo',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
		],
		callback: (e) => {
			if (!self) return
			const op = e.options.operation
			const soloChannels = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (soloChannels.length === 0) {
				self.log?.('warn', 'No valid input channels selected for solo')
				return
			}

			const soloSet = new Set(soloChannels)
			const currentSoloState = self.inputSoloState

			// Check if we're toggling the same solo selection
			const isSameSolo =
				currentSoloState &&
				currentSoloState.soloChannels.size === soloSet.size &&
				[...soloSet].every((ch) => currentSoloState.soloChannels.has(ch))

			let shouldApplySolo = false
			if (op === 'on') {
				shouldApplySolo = true
			} else if (op === 'off') {
				shouldApplySolo = false
			} else {
				// toggle
				shouldApplySolo = !isSameSolo
			}

			if (shouldApplySolo) {
				// Apply solo: unmute selected, mute others
				for (let ch = 1; ch <= NUM_INPUTS; ch++) {
					if (soloSet.has(ch)) {
						if (typeof self._setMute === 'function') {
							self._setMute('input', ch, false)
						}
					} else {
						if (typeof self._setMute === 'function') {
							self._setMute('input', ch, true)
						}
					}
				}
				self.inputSoloState = { soloChannels: soloSet }
				self.log?.('info', `Soloed input channels: ${soloChannels.join(', ')}`)
			} else {
				// Unsolo: unmute all
				for (let ch = 1; ch <= NUM_INPUTS; ch++) {
					if (typeof self._setMute === 'function') {
						self._setMute('input', ch, false)
					}
				}
				self.inputSoloState = null
				self.log?.('info', `Unsolo - unmuted all input channels`)
			}

			// Update feedbacks
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('input_muted', 'input_soloed')
			}
		},
	}

	actions['mute_all'] = {
		name: 'System: Mute All (Inputs & Outputs)',
		options: [
			{
				type: 'dropdown',
				id: 'op',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Mute ALL (Inputs & Outputs)' },
					{ id: 'off', label: 'Unmute ALL (Inputs & Outputs)' },
					{ id: 'toggle', label: 'Toggle ALL' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const op = e && e.options && e.options.op ? e.options.op : 'toggle'

			const allInputsMuted = (() => {
				for (let ch = 1; ch <= NUM_INPUTS; ch++) {
					if (self?.inMute?.[ch] !== true) return false
				}
				return true
			})()
			const allOutputsMuted = (() => {
				for (let ch = 1; ch <= NUM_OUTPUTS; ch++) {
					if (self?.outMute?.[ch] !== true) return false
				}
				return true
			})()

			if (op === 'on') {
				if (typeof self._muteAllInputs === 'function') self._muteAllInputs()
				if (typeof self._muteAllOutputs === 'function') self._muteAllOutputs()
				return
			}
			if (op === 'off') {
				if (typeof self._unmuteAllInputs === 'function') self._unmuteAllInputs()
				if (typeof self._unmuteAllOutputs === 'function') self._unmuteAllOutputs()
				return
			}

			const shouldUnmute = allInputsMuted && allOutputsMuted
			if (shouldUnmute) {
				if (typeof self._unmuteAllInputs === 'function') self._unmuteAllInputs()
				if (typeof self._unmuteAllOutputs === 'function') self._unmuteAllOutputs()
			} else {
				if (typeof self._muteAllInputs === 'function') self._muteAllInputs()
				if (typeof self._muteAllOutputs === 'function') self._muteAllOutputs()
			}
		},
	}

	actions['system_input_mode_set_multi'] = {
		name: 'System: Set input mode (Inputs 1-8)',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Device input channel(s)',
				default: [],
				choices: buildInputChoices(self, NUM_INPUTS),
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'mode',
				label: 'Mode',
				default: '1',
				choices: [
					{ id: '0', label: '0 - No Input' },
					{ id: '1', label: '1 - Analog' },
					{ id: '2', label: '2 - AES3L' },
					{ id: '3', label: '3 - AES3R' },
					{ id: '4', label: '4 - AVB' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const mode = Number(e.options.mode)
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid input channels selected')
				return
			}

			for (const ch of chs) {
				if (typeof self._setInputMode === 'function') {
					self._setInputMode(ch, mode)
				}
				if (typeof self._applyInputMode === 'function') {
					self._applyInputMode(ch, mode)
				}
			}
		},
	}

	actions['outputs_mute_control_multi'] = {
		name: 'Outputs: Mute',
		options: [
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Mute ON' },
					{ id: 'off', label: 'Mute OFF' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Select output(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
		],
		callback: (e) => {
			if (!self) return
			const op = e.options.operation
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			for (const ch of chs) {
				if (op === 'on' && typeof self._setMute === 'function') self._setMute('output', ch, true)
				else if (op === 'off' && typeof self._setMute === 'function') self._setMute('output', ch, false)
				else if (typeof self._toggleMute === 'function') self._toggleMute('output', ch)
			}
		},
	}

	actions['outputs_solo'] = {
		name: 'Outputs: Solo',
		options: [
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Solo ON (unmute selected, mute others)' },
					{ id: 'off', label: 'Solo OFF (unmute all)' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output(s) to solo',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
		],
		callback: (e) => {
			if (!self) return
			const op = e.options.operation
			const soloChannels = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (soloChannels.length === 0) {
				self.log?.('warn', 'No valid output channels selected for solo')
				return
			}

			const soloSet = new Set(soloChannels)
			const currentSoloState = self.outputSoloState

			// Check if we're toggling the same solo selection
			const isSameSolo =
				currentSoloState &&
				currentSoloState.soloChannels.size === soloSet.size &&
				[...soloSet].every((ch) => currentSoloState.soloChannels.has(ch))

			let shouldApplySolo = false
			if (op === 'on') {
				shouldApplySolo = true
			} else if (op === 'off') {
				shouldApplySolo = false
			} else {
				// toggle
				shouldApplySolo = !isSameSolo
			}

			if (shouldApplySolo) {
				// Apply solo: unmute selected, mute others
				for (let ch = 1; ch <= NUM_OUTPUTS; ch++) {
					if (soloSet.has(ch)) {
						if (typeof self._setMute === 'function') {
							self._setMute('output', ch, false)
						}
					} else {
						if (typeof self._setMute === 'function') {
							self._setMute('output', ch, true)
						}
					}
				}
				self.outputSoloState = { soloChannels: soloSet }
				self.log?.('info', `Soloed output channels: ${soloChannels.join(', ')}`)
			} else {
				// Unsolo: unmute all
				for (let ch = 1; ch <= NUM_OUTPUTS; ch++) {
					if (typeof self._setMute === 'function') {
						self._setMute('output', ch, false)
					}
				}
				self.outputSoloState = null
				self.log?.('info', `Unsolo - unmuted all output channels`)
			}

			// Update feedbacks
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('output_muted', 'output_soloed')
			}
		},
	}

	actions['input_gain_set'] = {
		name: 'Input: Set gain (dB)',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input channel(s)',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'target',
				label: 'Set to',
				default: 'value',
				choices: [
					{ id: 'value', label: 'Specific dB value' },
					{ id: 'last', label: 'Last dB value' },
				],
			},
			{
				type: 'number',
				id: 'gain',
				label: 'Gain (dB)',
				default: 0,
				min: -90,
				max: 10,
				step: 0.1,
				isVisible: (o) => o.target === 'value',
			},
			{ type: 'number', id: 'fadeMs', label: 'Fade duration (ms)', default: 0, min: 0, max: 600000, step: 10 },
			{
				type: 'dropdown',
				id: 'curve',
				label: 'Curve (used if fading)',
				default: 'linear',
				choices: [
					{ id: 'linear', label: 'Linear (dB)' },
					{ id: 'log', label: 'Logarithmic' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid input channels selected')
				return
			}
			const mode = e.options.target === 'last' || e.options.target === 'prev' ? 'last' : 'value'
			const dur = Math.max(0, Number(e.options.fadeMs) || 0)
			const curve = e.options.curve === 'log' ? 'log' : 'linear'
			const btnId = e?.controlId || e?.event?.controlId || null

			if (mode === 'last') {
				for (const ch of chs) {
					const prev = typeof self._getPrevInputGain === 'function' ? self._getPrevInputGain(ch, btnId) : null
					if (prev == null) {
						self.log?.('debug', `Input ch ${ch}: no last dB stored`)
						continue
					}
					if (dur > 0 && typeof self._startInputGainFade === 'function') {
						self._startInputGainFade(ch, prev, dur, curve)
					} else if (typeof self._setInputGain === 'function') {
						self._setInputGain(ch, prev)
					}
				}
				return
			}

			const g = Number(e.options.gain)
			for (const ch of chs) {
				if (typeof self._subWrite === 'function') {
					self._subWrite(`/processing/input/${ch}/gain`)
				}
				if (typeof self._beginPrevCaptureWindow === 'function') {
					self._beginPrevCaptureWindow('input', ch, btnId, 300)
				}
				if (typeof self._rememberPrevInputGain === 'function') {
					self._rememberPrevInputGain(ch, btnId)
				}
				if (dur > 0 && typeof self._startInputGainFade === 'function') {
					self._startInputGainFade(ch, g, dur, curve)
				} else if (typeof self._setInputGain === 'function') {
					self._setInputGain(ch, g)
				}
			}
		},
	}

	actions['input_gain_revert'] = {
		name: 'Input: Revert to previous gain',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input channel(s)',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
			{ type: 'number', id: 'fadeMs', label: 'Fade duration (ms)', default: 0, min: 0, max: 600000, step: 10 },
			{
				type: 'dropdown',
				id: 'curve',
				label: 'Curve (used if fading)',
				default: 'linear',
				choices: [
					{ id: 'linear', label: 'Linear (dB)' },
					{ id: 'log', label: 'Logarithmic' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid input channels selected')
				return
			}
			const dur = Math.max(0, Number(e.options.fadeMs) || 0)
			const curve = e.options.curve === 'log' ? 'log' : 'linear'
			const btnId = e?.controlId || e?.event?.controlId || null

			for (const ch of chs) {
				const prev = typeof self._getPrevInputGain === 'function' ? self._getPrevInputGain(ch, btnId) : null
				if (prev == null) {
					self.log?.('info', `Input ch ${ch}: no previous gain stored; revert skipped`)
					continue
				}
				if (dur > 0 && typeof self._startInputGainFade === 'function') {
					self._startInputGainFade(ch, prev, dur, curve)
				} else if (typeof self._setInputGain === 'function') {
					self._setInputGain(ch, prev)
				}
			}
		},
	}

	actions['input_delay_set'] = {
		name: 'Input: Set delay (ms)',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input channel(s)',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
			{ type: 'number', id: 'ms', label: 'Delay (ms)', default: 0, min: 0, max: 500, step: 0.01 },
			{ type: 'checkbox', id: 'relative', label: 'Add to current delay (relative)', default: false },
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid input channels selected')
				return
			}
			const wantRelative = !!e.options.relative
			const reqMs = Number(e.options.ms)
			const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))
			const roundTo01 = (v) => Math.round(v / 0.01) * 0.01

			for (const ch of chs) {
				let targetMs = clamp(Number.isFinite(reqMs) ? reqMs : 0, 0, 2000)
				if (wantRelative) {
					const curMs = Number(self?.inputDelay?.[ch]?.ms)
					if (Number.isFinite(curMs)) targetMs = curMs + targetMs
				}
				targetMs = roundTo01(targetMs)

				if (typeof self._setInputDelayMs === 'function') {
					self._setInputDelayMs(ch, targetMs)
				} else if (typeof self._cmdSendLine === 'function') {
					const samples = Math.round(targetMs * 96)
					self._cmdSendLine(`/processing/input/${ch}/delay=${samples}`)
					if (typeof self._applyInputDelay === 'function') {
						self._applyInputDelay(ch, samples)
					}
				}
			}
		},
	}

	actions['input_link_group_bypass'] = {
		name: 'Input: Link Group Bypass',
		options: [
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Bypass ON' },
					{ id: 'off', label: 'Bypass OFF' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
			{
				type: 'multidropdown',
				id: 'groups',
				label: 'Link Group(s)',
				default: [],
				choices: [
					{ id: '1', label: 'Link Group 1' },
					{ id: '2', label: 'Link Group 2' },
					{ id: '3', label: 'Link Group 3' },
					{ id: '4', label: 'Link Group 4' },
				],
				minSelection: 0,
			},
		],
		callback: (e) => {
			if (!self) return
			const op = e.options.operation
			const groups = Array.isArray(e.options.groups)
				? e.options.groups.map((g) => Number(g)).filter((g) => g >= 1 && g <= 4)
				: []

			if (groups.length === 0) {
				self.log?.('warn', 'No valid link groups selected')
				return
			}

			for (const group of groups) {
				const currentBypass = self?.inputLinkGroupBypass?.[group]
				let targetBypass = false

				if (op === 'on') {
					targetBypass = true
				} else if (op === 'off') {
					targetBypass = false
				} else {
					targetBypass = currentBypass !== true
				}

				const value = targetBypass ? 'true' : 'false'
				self._cmdSendLine(`/device/input_link_group/${group}/bypass='${value}'`)

				// Update local state
				if (!self.inputLinkGroupBypass) self.inputLinkGroupBypass = {}
				self.inputLinkGroupBypass[group] = targetBypass

				self.log?.('info', `Input Link Group ${group} bypass: ${value}`)
			}

			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('input_link_group_bypassed')
			}
		},
	}

	actions['output_link_group_bypass'] = {
		name: 'Output: Link Group Bypass',
		options: [
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Bypass ON' },
					{ id: 'off', label: 'Bypass OFF' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
			{
				type: 'multidropdown',
				id: 'groups',
				label: 'Link Group(s)',
				default: [],
				choices: [
					{ id: '1', label: 'Link Group 1' },
					{ id: '2', label: 'Link Group 2' },
					{ id: '3', label: 'Link Group 3' },
					{ id: '4', label: 'Link Group 4' },
					{ id: '5', label: 'Link Group 5' },
					{ id: '6', label: 'Link Group 6' },
					{ id: '7', label: 'Link Group 7' },
					{ id: '8', label: 'Link Group 8' },
				],
				minSelection: 0,
			},
		],
		callback: (e) => {
			if (!self) return
			const op = e.options.operation
			const groups = Array.isArray(e.options.groups)
				? e.options.groups.map((g) => Number(g)).filter((g) => g >= 1 && g <= 8)
				: []

			if (groups.length === 0) {
				self.log?.('warn', 'No valid output link groups selected')
				return
			}

			for (const group of groups) {
				const currentBypass = self?.outputLinkGroupBypass?.[group]
				let targetBypass = false

				if (op === 'on') {
					targetBypass = true
				} else if (op === 'off') {
					targetBypass = false
				} else {
					targetBypass = currentBypass !== true
				}

				const value = targetBypass ? 'true' : 'false'
				self._cmdSendLine(`/device/output_link_group/${group}/bypass='${value}'`)

				// Update local state
				if (!self.outputLinkGroupBypass) self.outputLinkGroupBypass = {}
				self.outputLinkGroupBypass[group] = targetBypass

				self.log?.('info', `Output Link Group ${group} bypass: ${value}`)
			}

			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('output_link_group_bypassed')
			}
		},
	}

	actions['input_link_group_assign'] = {
		name: 'Input: Assign to Link Group',
		options: [
			{
				type: 'multidropdown',
				id: 'channels',
				label: 'Input Channel(s)',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'link_group',
				label: 'Link Group',
				default: '0',
				choices: [
					{ id: '0', label: 'Unassign' },
					{ id: '1', label: 'Link Group 1' },
					{ id: '2', label: 'Link Group 2' },
					{ id: '3', label: 'Link Group 3' },
					{ id: '4', label: 'Link Group 4' },
				],
			},
		],
		callback: (e) => {
			if (!self) return

			const channels = e.options.channels || []
			const linkGroup = String(e.options.link_group || '0')

			for (const ch of channels) {
				const chNum = Number(ch)
				if (chNum < 1 || chNum > NUM_INPUTS) continue

				self._cmdSendLine(`/device/input/${chNum}/input_link_group=${linkGroup}`)

				// Update local state
				if (!self.inputLinkGroupAssign) self.inputLinkGroupAssign = {}
				self.inputLinkGroupAssign[chNum] = Number(linkGroup)

				const groupLabel = linkGroup === '0' ? 'Unassigned' : `Link Group ${linkGroup}`
				self.log?.('info', `Input ${chNum} assigned to: ${groupLabel}`)
			}

			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('input_link_group_assigned')
			}
		},
	}

	actions['output_link_group_assign'] = {
		name: 'Output: Assign to Link Group',
		options: [
			{
				type: 'multidropdown',
				id: 'channels',
				label: 'Output Channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'link_group',
				label: 'Link Group',
				default: '0',
				choices: [
					{ id: '0', label: 'Unassign' },
					{ id: '1', label: 'Link Group 1' },
					{ id: '2', label: 'Link Group 2' },
					{ id: '3', label: 'Link Group 3' },
					{ id: '4', label: 'Link Group 4' },
					{ id: '5', label: 'Link Group 5' },
					{ id: '6', label: 'Link Group 6' },
					{ id: '7', label: 'Link Group 7' },
					{ id: '8', label: 'Link Group 8' },
				],
			},
		],
		callback: (e) => {
			if (!self) return

			const channels = e.options.channels || []
			const linkGroup = String(e.options.link_group || '0')

			for (const ch of channels) {
				const chNum = Number(ch)
				if (chNum < 1 || chNum > NUM_OUTPUTS) continue

				self._cmdSendLine(`/device/output/${chNum}/output_link_group='${linkGroup}'`)

				// Update local state
				if (!self.outputLinkGroupAssign) self.outputLinkGroupAssign = {}
				self.outputLinkGroupAssign[chNum] = Number(linkGroup)

				const groupLabel = linkGroup === '0' ? 'Unassigned' : `Link Group ${linkGroup}`
				self.log?.('info', `Output ${chNum} assigned to: ${groupLabel}`)
			}

			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('output_link_group_assigned')
			}
		},
	}

	actions['input_ushaping_adjust'] = {
		name: 'Input: U-Shaping EQ',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input channel(s)',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: '1',
				choices: [
					{ id: '1', label: 'Band 1 (62 Hz)' },
					{ id: '2', label: 'Band 2 (250 Hz)' },
					{ id: '3', label: 'Band 3 (1 kHz)' },
					{ id: '4', label: 'Band 4 (4 kHz)' },
					{ id: '5', label: 'Band 5 (HF)' },
				],
			},
			{
				type: 'dropdown',
				id: 'param',
				label: 'Parameter',
				default: 'gain',
				choices: [
					{ id: 'gain', label: 'Gain' },
					{ id: 'frequency', label: 'Frequency' },
					{ id: 'slope', label: 'Slope' },
				],
			},
			{
				type: 'dropdown',
				id: 'mode',
				label: 'Mode',
				default: 'set',
				choices: [
					{ id: 'set', label: 'Set to value' },
					{ id: 'adjust', label: 'Adjust by delta (for knobs)' },
				],
			},
			{
				type: 'number',
				id: 'gain_value',
				label: 'Gain (dB)',
				default: 0,
				min: -18,
				max: 18,
				step: 0.1,
				isVisible: (o) => o.param === 'gain' && o.mode === 'set',
			},
			{
				type: 'number',
				id: 'gain_delta',
				label: 'Gain delta (dB)',
				default: 0.5,
				min: -18,
				max: 18,
				step: 0.1,
				isVisible: (o) => o.param === 'gain' && o.mode === 'adjust',
			},
			{
				type: 'number',
				id: 'freq_value',
				label: 'Frequency (Hz)',
				default: 1000,
				min: 10,
				max: 20000,
				step: 1,
				isVisible: (o) => o.param === 'frequency' && o.mode === 'set' && o.band !== '5',
			},
			{
				type: 'number',
				id: 'freq_delta',
				label: 'Frequency delta (Hz)',
				default: 10,
				min: -1000,
				max: 1000,
				step: 1,
				isVisible: (o) => o.param === 'frequency' && o.mode === 'adjust' && o.band !== '5',
			},
			{
				type: 'number',
				id: 'slope_value',
				label: 'Slope',
				default: 1,
				min: 0.1,
				max: 2,
				step: 0.1,
				isVisible: (o) => o.param === 'slope' && o.mode === 'set' && o.band !== '5',
			},
			{
				type: 'number',
				id: 'slope_delta',
				label: 'Slope delta',
				default: 0.1,
				min: -2,
				max: 2,
				step: 0.1,
				isVisible: (o) => o.param === 'slope' && o.mode === 'adjust' && o.band !== '5',
			},
			{
				type: 'static-text',
				id: 'band5_note',
				label: 'Note',
				value: 'Band 5 (HF) only has gain parameter',
				isVisible: (o) => o.band === '5' && o.param !== 'gain',
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid input channels selected')
				return
			}

			const band = Number(e.options.band)
			const param = e.options.param
			const mode = e.options.mode

			// Band 5 only supports gain
			if (band === 5 && param !== 'gain') {
				self.log?.('warn', 'Band 5 only supports gain parameter')
				return
			}

			for (const ch of chs) {
				let finalValue

				if (mode === 'adjust') {
					// Get current value and adjust it
					let currentValue = 0
					if (param === 'gain') {
						currentValue = Number(self?.inputUShaping?.[ch]?.[band]?.gain ?? 0)
						const delta = Number(e.options.gain_delta ?? 0)
						finalValue = Math.max(-18, Math.min(18, currentValue + delta))
					} else if (param === 'frequency') {
						currentValue = Number(self?.inputUShaping?.[ch]?.[band]?.frequency ?? 1000)
						const delta = Number(e.options.freq_delta ?? 0)
						finalValue = Math.max(10, Math.min(20000, currentValue + delta))
					} else if (param === 'slope') {
						currentValue = Number(self?.inputUShaping?.[ch]?.[band]?.slope ?? 1)
						const delta = Number(e.options.slope_delta ?? 0)
						finalValue = Math.max(0.1, Math.min(2, currentValue + delta))
					}
				} else {
					// Set to absolute value
					if (param === 'gain') {
						finalValue = Math.max(-18, Math.min(18, Number(e.options.gain_value ?? 0)))
					} else if (param === 'frequency') {
						finalValue = Math.max(10, Math.min(20000, Number(e.options.freq_value ?? 1000)))
					} else if (param === 'slope') {
						finalValue = Math.max(0.1, Math.min(2, Number(e.options.slope_value ?? 1)))
					}
				}

				// Send the command
				self._cmdSendLine(`/processing/input/${ch}/ushaping/${band}/${param}=${finalValue}`)

				// Update internal state if available
				if (typeof self._applyInputUShaping === 'function') {
					self._applyInputUShaping(ch, band, param, finalValue)
				}

				self.log?.('info', `Input ch ${ch}: U-Shaping band ${band} ${param} = ${finalValue}`)
			}
		},
	}

	actions['input_ushaping_bypass'] = {
		name: 'Input: U-Shaping Bypass',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input channel(s)',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Enabled' },
					{ id: 'off', label: 'Bypass' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid input channels selected')
				return
			}

			const op = String(e.options.operation || 'toggle')

			for (const ch of chs) {
				let state
				if (op === 'toggle') {
					const current = self?.inputUShaping?.[ch]?.bypass
					const currentBool =
						typeof current === 'boolean' ? current : /^(true|1|on)$/i.test(String(current ?? '').trim())
					state = !currentBool
				} else {
					const enable = op === 'on'
					state = !enable
				}

				self._cmdSendLine(`/processing/input/${ch}/ushaping/bypass=${state ? 'true' : 'false'}`)

				if (typeof self._applyInputUShapingBypass === 'function') {
					self._applyInputUShapingBypass(ch, state)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_ushaping_bypass`]: state ? 'ON' : 'OFF',
					})
				}

				self.log?.('info', `Input ch ${ch}: U-Shaping bypass ${state ? 'ON' : 'OFF'}`)
			}
		},
	}

	// U-Shaping Knob Control System - Selection Actions
	actions['input_ushaping_select_input'] = {
		name: 'Input: U-Shaping Select Input Channel(s)',
		description: 'Select which input channel(s) the U-Shaping knobs will control (can select multiple to link them)',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input channel(s)',
				default: ['1'],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid input channels selected')
				return
			}

			// Store the selected input channels (array)
			if (!self._ushapingKnobControl) self._ushapingKnobControl = {}
			self._ushapingKnobControl.selectedInputs = chs

			// Update variable
			if (typeof self.setVariableValues === 'function') {
				const names = chs
					.map((ch) => {
						const name = self?.inputName?.[ch]
						return name ? `${ch} (${name})` : `${ch}`
					})
					.join(', ')

				self.setVariableValues({
					ushaping_selected_input: names,
					ushaping_selected_input_num: chs.join(','),
				})

				// Update dynamic current value variables
				if (typeof self._updateUShapingCurrentValues === 'function') {
					self._updateUShapingCurrentValues()
				}
			}

			// Update feedbacks
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('ushaping_input_selected')
			}

			const channelList = chs
				.map((ch) => {
					const name = self?.inputName?.[ch]
					return name ? `${ch} (${name})` : `${ch}`
				})
				.join(', ')

			self.log?.('info', `U-Shaping: Selected input(s): ${channelList}`)
		},
	}

	actions['input_ushaping_select_band'] = {
		name: 'Input: U-Shaping Select Band',
		description: 'Select which band (1-5) the U-Shaping knobs will control',
		options: [
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: '1',
				choices: [
					{ id: '1', label: 'Input U-Shaping Band 1' },
					{ id: '2', label: 'Input U-Shaping Band 2' },
					{ id: '3', label: 'Input U-Shaping Band 3' },
					{ id: '4', label: 'Input U-Shaping Band 4' },
					{ id: '5', label: 'Input U-Shaping Band 5' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const band = Number(e.options.band)
			if (!Number.isFinite(band) || band < 1 || band > 5) {
				self.log?.('warn', `Invalid band: ${e.options.band}`)
				return
			}

			// Store the selected band
			if (!self._ushapingKnobControl) self._ushapingKnobControl = {}
			self._ushapingKnobControl.selectedBand = band

			// Update variable
			if (typeof self.setVariableValues === 'function') {
				const bandLabels = {
					1: 'Input U-Shaping Band 1',
					2: 'Input U-Shaping Band 2',
					3: 'Input U-Shaping Band 3',
					4: 'Input U-Shaping Band 4',
					5: 'Input U-Shaping Band 5',
				}
				self.setVariableValues({
					ushaping_selected_band: bandLabels[band],
					ushaping_selected_band_num: band,
				})

				// Update dynamic current value variables
				if (typeof self._updateUShapingCurrentValues === 'function') {
					self._updateUShapingCurrentValues()
				}
			}

			// Update feedbacks
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('ushaping_band_selected')
			}

			const bandNames = ['', '20-2500 Hz', '40-5000 Hz', '80-10k Hz', '160-20k Hz', 'HF (no freq)']
			self.log?.('info', `U-Shaping: Selected Band ${band} (${bandNames[band]})`)
		},
	}

	// U-Shaping Knob Control System - Knob Actions
	actions['input_ushaping_knob_gain'] = {
		name: 'Input: U-Shaping Knob - Gain',
		description: 'Adjust gain for the selected input(s) and band. Acceleration (3 tiers): 0.1 â†’ 0.3 â†’ 0.5 dB.',
		options: [
			{
				type: 'static-text',
				id: 'info',
				label: 'Selection',
				value: 'Uses currently selected input channel(s) and band. Use selection buttons to choose.',
			},
			{
				type: 'number',
				id: 'delta',
				label: 'Gain delta (dB) - for button press',
				default: 0.5,
				min: -15,
				max: 15,
				step: 0.1,
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const chs = self?._ushapingKnobControl?.selectedInputs || [1]
			const band = self?._ushapingKnobControl?.selectedBand || 1
			let delta = Number(e.options.delta ?? 0)

			// Time-based acceleration for rotary encoders
			if (e.surfaceId !== undefined) {
				const now = Date.now()
				const accelKey = `ushaping_gain_${e.surfaceId || 'default'}`

				if (!self._rotaryAccel) self._rotaryAccel = {}

				const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
				const timeDiff = now - lastRotation.time

				// 4-tier acceleration based on rotation speed
				let speedTier = 0
				if (timeDiff < 100) {
					speedTier = Math.min(lastRotation.count + 1, 3)
				}

				self._rotaryAccel[accelKey] = { time: now, count: speedTier }

				// Acceleration tiers: 0 = 0.1dB, 1 = 0.5dB, 2 = 1dB, 3 = 2dB (faster)
				const deltaTiers = [0.1, 0.5, 1.0, 2.0]
				delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
			}

			// Initialize storage if needed
			if (!self.inputUShaping) self.inputUShaping = {}

			for (const ch of chs) {
				if (!self.inputUShaping[ch]) self.inputUShaping[ch] = {}
				if (!self.inputUShaping[ch][band]) self.inputUShaping[ch][band] = {}

				const currentValue = Number(self.inputUShaping[ch][band].gain ?? 0)
				const newValue = currentValue + delta
				const finalValue = Math.max(-15, Math.min(15, newValue))

				// Update internal state
				self.inputUShaping[ch][band].gain = finalValue

				self._cmdSendLine(`/processing/input/${ch}/ushaping/${band}/gain=${finalValue}`)

				if (typeof self._applyInputUShaping === 'function') {
					self._applyInputUShaping(ch, band, 'gain', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_ushaping_band${band}_gain`]: finalValue.toFixed(1),
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				const deltaStr = delta >= 0 ? `+${delta.toFixed(1)}` : delta.toFixed(1)
				self.log?.(
					'info',
					`U-Shaping: Input ${ch}${inputName} Band ${band} gain ${currentValue.toFixed(1)} ${deltaStr} = ${finalValue.toFixed(1)} dB`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateUShapingCurrentValues === 'function') {
				self._updateUShapingCurrentValues()
			}
		},
	}

	actions['input_ushaping_knob_frequency'] = {
		name: 'Input: U-Shaping Knob - Frequency',
		description:
			'Adjust frequency for the selected input(s) and band (B1: 20-2500Hz, B2: 40-5000Hz, B3: 80-10kHz, B4: 160-20kHz). Octave-based acceleration adapts to current frequency for natural control.',
		options: [
			{
				type: 'static-text',
				id: 'info',
				label: 'Selection',
				value: 'Uses currently selected input channel(s) and band. Band 5 (HF) does not have frequency.',
			},
			{
				type: 'number',
				id: 'delta',
				label: 'Frequency delta (Hz) - for button press',
				default: 10,
				min: -1000,
				max: 1000,
				step: 1,
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const chs = self?._ushapingKnobControl?.selectedInputs || [1]
			const band = self?._ushapingKnobControl?.selectedBand || 1

			// Band 5 doesn't have frequency
			if (band === 5) {
				self.log?.('warn', 'U-Shaping: Band 5 (HF) does not have frequency parameter')
				return
			}

			// Band-specific frequency ranges
			const freqRanges = {
				1: { min: 20, max: 2500, default: 62 },
				2: { min: 40, max: 5000, default: 250 },
				3: { min: 80, max: 10000, default: 1000 },
				4: { min: 160, max: 20000, default: 4000 },
			}
			const range = freqRanges[band] || { min: 20, max: 20000, default: 1000 }

			// Initialize storage if needed
			if (!self.inputUShaping) self.inputUShaping = {}

			for (const ch of chs) {
				if (!self.inputUShaping[ch]) self.inputUShaping[ch] = {}
				if (!self.inputUShaping[ch][band]) self.inputUShaping[ch][band] = {}

				const currentValue = Number(self.inputUShaping[ch][band].frequency ?? range.default)
				let delta = Number(e.options.delta ?? 0)

				// Time-based acceleration for rotary encoders with range-based tiers
				if (e.surfaceId !== undefined) {
					const now = Date.now()
					const accelKey = `ushaping_freq_${e.surfaceId || 'default'}`

					if (!self._rotaryAccel) self._rotaryAccel = {}

					const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
					const timeDiff = now - lastRotation.time

					// 4-tier acceleration based on rotation speed
					let speedTier = 0
					if (timeDiff < 100) {
						speedTier = Math.min(lastRotation.count + 1, 3)
					}

					self._rotaryAccel[accelKey] = { time: now, count: speedTier }

					// Octave-based acceleration tiers based on CURRENT frequency (4 tiers: 0, 1, 2, 3)
					// Organized by octave ranges for better musical/logarithmic control
					let deltaTiers
					if (currentValue < 31) {
						// 10-31 Hz (sub-bass): 0.5, 1, 2, 4 (faster)
						deltaTiers = [0.5, 1, 2, 4]
					} else if (currentValue < 63) {
						// 31-63 Hz: 1, 2, 5, 10 (faster)
						deltaTiers = [1, 2, 5, 10]
					} else if (currentValue < 125) {
						// 63-125 Hz: 2, 5, 10, 20 (faster)
						deltaTiers = [2, 5, 10, 20]
					} else if (currentValue < 250) {
						// 125-250 Hz: 5, 10, 20, 40 (faster)
						deltaTiers = [5, 10, 20, 40]
					} else if (currentValue < 500) {
						// 250-500 Hz: 10, 20, 50, 100 (faster)
						deltaTiers = [10, 20, 50, 100]
					} else if (currentValue < 1000) {
						// 500-1000 Hz: 20, 50, 100, 200 (faster)
						deltaTiers = [20, 50, 100, 200]
					} else if (currentValue < 2000) {
						// 1k-2k Hz: 50, 100, 200, 500 (faster)
						deltaTiers = [50, 100, 200, 500]
					} else if (currentValue < 4000) {
						// 2k-4k Hz: 100, 200, 500, 1000 (faster)
						deltaTiers = [100, 200, 500, 1000]
					} else if (currentValue < 8000) {
						// 4k-8k Hz: 200, 500, 1000, 2000 (faster)
						deltaTiers = [200, 500, 1000, 2000]
					} else if (currentValue < 16000) {
						// 8k-16k Hz: 500, 1000, 2000, 4000 (faster)
						deltaTiers = [500, 1000, 2000, 4000]
					} else {
						// 16k-20k Hz: 1000, 2000, 3000, 5000 (faster)
						deltaTiers = [1000, 2000, 3000, 5000]
					}
					delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
				}
				const newValue = currentValue + delta
				const finalValue = Math.max(range.min, Math.min(range.max, newValue))

				// Update internal state
				self.inputUShaping[ch][band].frequency = finalValue

				self._cmdSendLine(`/processing/input/${ch}/ushaping/${band}/frequency=${finalValue}`)

				if (typeof self._applyInputUShaping === 'function') {
					self._applyInputUShaping(ch, band, 'frequency', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_ushaping_band${band}_frequency`]: Math.round(finalValue).toString(),
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				const deltaStr = delta >= 0 ? `+${delta}` : delta
				self.log?.(
					'info',
					`U-Shaping: Input ${ch}${inputName} Band ${band} frequency ${currentValue} ${deltaStr} = ${finalValue} Hz`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateUShapingCurrentValues === 'function') {
				self._updateUShapingCurrentValues()
			}
		},
	}

	actions['input_ushaping_knob_slope'] = {
		name: 'Input: U-Shaping Knob - Slope (dB/oct)',
		description:
			'Cycle through slope values for the selected input(s) and band (6, 12, 18, 24, 30, 36, 42, 48 dB/oct). Acceleration (3 tiers): 1 â†’ 2 â†’ 3 steps.',
		options: [
			{
				type: 'static-text',
				id: 'info',
				label: 'Selection',
				value: 'Uses currently selected input channel(s) and band (all bands including Band 5).',
			},
			{
				type: 'dropdown',
				id: 'direction',
				label: 'Direction - for button press',
				default: 'up',
				choices: [
					{ id: 'up', label: 'Cycle Up (6â†’12â†’18â†’...)' },
					{ id: 'down', label: 'Cycle Down (...â†’18â†’12â†’6)' },
				],
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const chs = self?._ushapingKnobControl?.selectedInputs || [1]
			const band = self?._ushapingKnobControl?.selectedBand || 1

			// Determine direction and step count
			let direction = e.options.direction || 'up'
			let stepCount = 1

			// Time-based acceleration for rotary encoders
			if (e.surfaceId !== undefined) {
				const now = Date.now()
				const accelKey = `ushaping_slope_${e.surfaceId || 'default'}`

				if (!self._rotaryAccel) self._rotaryAccel = {}

				const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
				const timeDiff = now - lastRotation.time

				// 4-tier acceleration based on rotation speed
				let speedTier = 0
				if (timeDiff < 100) {
					speedTier = Math.min(lastRotation.count + 1, 3)
				}

				self._rotaryAccel[accelKey] = { time: now, count: speedTier }

				// Acceleration tiers: 0 = 1 step, 1 = 2 steps, 2 = 3 steps, 3 = 4 steps
				const stepTiers = [1, 2, 3, 4]
				stepCount = stepTiers[speedTier]
			}

			// Available slope values: 6, 12, 18, 24, 30, 36, 42, 48 dB/oct
			const slopeValues = [6, 12, 18, 24, 30, 36, 42, 48]

			// Initialize storage if needed
			if (!self.inputUShaping) self.inputUShaping = {}

			for (const ch of chs) {
				if (!self.inputUShaping[ch]) self.inputUShaping[ch] = {}
				if (!self.inputUShaping[ch][band]) self.inputUShaping[ch][band] = {}

				const currentValue = Number(self.inputUShaping[ch][band].slope ?? 12)

				// Find closest slope value to current
				let currentIndex = 0
				let minDiff = Math.abs(slopeValues[0] - currentValue)
				for (let i = 1; i < slopeValues.length; i++) {
					const diff = Math.abs(slopeValues[i] - currentValue)
					if (diff < minDiff) {
						minDiff = diff
						currentIndex = i
					}
				}

				// Move to next or previous value by stepCount
				let newIndex
				if (direction === 'up') {
					newIndex = (currentIndex + stepCount) % slopeValues.length
				} else {
					newIndex = (currentIndex - stepCount + slopeValues.length) % slopeValues.length
				}
				const finalValue = slopeValues[newIndex]

				// Update internal state
				self.inputUShaping[ch][band].slope = finalValue

				self._cmdSendLine(`/processing/input/${ch}/ushaping/${band}/slope=${finalValue}`)

				if (typeof self._applyInputUShaping === 'function') {
					self._applyInputUShaping(ch, band, 'slope', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_ushaping_band${band}_slope`]: Math.round(finalValue).toString(),
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				self.log?.(
					'info',
					`U-Shaping: Input ${ch}${inputName} Band ${band} slope ${currentValue} dB/oct â†’ ${finalValue} dB/oct`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateUShapingCurrentValues === 'function') {
				self._updateUShapingCurrentValues()
			}
		},
	}

	actions['input_ushaping_knob_band_bypass'] = {
		name: 'Input: U-Shaping Band Bypass (Rotary)',
		description: 'Toggle U-Shaping band bypass for selected input(s) and selected band. Push button action.',
		options: [],
		callback: () => {
			if (!self._ushapingKnobControl) return

			const chs = self._ushapingKnobControl.selectedInputs || [1]
			const band = self._ushapingKnobControl.selectedBand || 1

			// U-Shaping has 5 bands
			if (band < 1 || band > 5) return

			for (const ch of chs) {
				if (ch < 1 || ch > NUM_INPUTS) continue

				// Initialize state if needed
				if (!self.inputUShaping) self.inputUShaping = {}
				if (!self.inputUShaping[ch]) self.inputUShaping[ch] = {}
				if (!self.inputUShaping[ch][band]) self.inputUShaping[ch][band] = {}

				// Get current bypass state (default to false if unknown)
				const currentBypass = self.inputUShaping[ch][band].band_bypass || false
				const newBypass = !currentBypass

				// Send command to device
				self._cmdSendLine(`/processing/input/${ch}/ushaping/${band}/band_bypass=${newBypass}`)

				// Update internal state
				self.inputUShaping[ch][band].band_bypass = newBypass

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_ushaping_band${band}_bypass`]: newBypass ? 'ON' : 'OFF',
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				self.log?.(
					'info',
					`U-Shaping: Input ${ch}${inputName} Band ${band} bypass ${currentBypass ? 'ON' : 'OFF'} â†’ ${newBypass ? 'ON' : 'OFF'}`,
				)
			}
		},
	}

	// ===== Input Parametric EQ (knob-based selection) =====

	actions['input_eq_select_input'] = {
		name: 'Input: Parametric EQ Select Input Channel(s)',
		description:
			'Select which input channel(s) the Parametric EQ knobs will control. Multiple channels can be linked together.',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input channel(s)',
				default: ['1'],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
		],
		callback: (e) => {
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			if (!self._eqKnobControl) self._eqKnobControl = {}
			self._eqKnobControl.selectedInputs = chs

			// Update variables to show selected inputs
			const names = chs
				.map((ch) => {
					const nm = self?.inputName?.[ch]
					return nm ? `Input ${ch} (${nm})` : `Input ${ch}`
				})
				.join(', ')

			if (typeof self.setVariableValues === 'function') {
				self.setVariableValues({
					eq_selected_input: names,
					eq_selected_input_num: chs.join(','),
				})

				// Update dynamic current value variables
				if (typeof self._updateEQCurrentValues === 'function') {
					self._updateEQCurrentValues()
				}
			}

			// Update feedbacks if they exist
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('eq_input_selected')
			}
		},
	}

	actions['input_eq_select_band'] = {
		name: 'Input: Parametric EQ Select Band',
		description: 'Select which band (1-5) the Parametric EQ knobs will control.',
		options: [
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: 1,
				choices: [
					{ id: 1, label: 'Input PEQ Band 1' },
					{ id: 2, label: 'Input PEQ Band 2' },
					{ id: 3, label: 'Input PEQ Band 3' },
					{ id: 4, label: 'Input PEQ Band 4' },
					{ id: 5, label: 'Input PEQ Band 5' },
				],
			},
		],
		callback: (e) => {
			const band = Number(e.options.band ?? 1)
			if (!self._eqKnobControl) self._eqKnobControl = {}
			self._eqKnobControl.selectedBand = band

			const bandLabels = {
				1: 'Input PEQ Band 1',
				2: 'Input PEQ Band 2',
				3: 'Input PEQ Band 3',
				4: 'Input PEQ Band 4',
				5: 'Input PEQ Band 5',
			}

			if (typeof self.setVariableValues === 'function') {
				self.setVariableValues({
					eq_selected_band: bandLabels[band],
					eq_selected_band_num: band,
				})

				// Update dynamic current value variables
				if (typeof self._updateEQCurrentValues === 'function') {
					self._updateEQCurrentValues()
				}
			}

			// Update feedbacks if they exist
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('eq_band_selected')
			}
		},
	}

	actions['input_eq_knob_gain'] = {
		name: 'Input: Parametric EQ Knob - Gain',
		description:
			'Adjust gain for the selected input(s) and band. Range: -18 to +18 dB. Acceleration (3 tiers): 0.1 â†’ 0.5 â†’ 1 dB.',
		options: [
			{
				type: 'number',
				id: 'delta',
				label: 'Delta (dB) - for button press',
				default: 0.1,
				min: -18,
				max: 18,
				step: 0.1,
			},
		],
		callback: (e) => {
			const chs = self?._eqKnobControl?.selectedInputs || [1]
			const band = self?._eqKnobControl?.selectedBand || 1
			let delta = Number(e.options.delta ?? 0)

			// Time-based acceleration for rotary encoders
			if (e.surfaceId !== undefined) {
				const now = Date.now()
				const accelKey = `eq_gain_${e.surfaceId || 'default'}`

				if (!self._rotaryAccel) self._rotaryAccel = {}

				const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
				const timeDiff = now - lastRotation.time

				// 4-tier acceleration based on rotation speed
				let speedTier = 0
				if (timeDiff < 100) {
					speedTier = Math.min(lastRotation.count + 1, 3)
				}

				self._rotaryAccel[accelKey] = { time: now, count: speedTier }

				// Acceleration tiers: 0 = 0.1dB, 1 = 0.5dB, 2 = 1dB, 3 = 2dB (faster)
				const deltaTiers = [0.1, 0.5, 1.0, 2.0]
				delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
			}

			if (!self.inputEQ) self.inputEQ = {}

			for (const ch of chs) {
				if (!self.inputEQ[ch]) self.inputEQ[ch] = {}
				if (!self.inputEQ[ch][band]) self.inputEQ[ch][band] = {}

				const currentValue = Number(self.inputEQ[ch][band].gain ?? 0)
				const newValue = currentValue + delta
				const finalValue = Math.max(-18, Math.min(18, newValue))

				self.inputEQ[ch][band].gain = finalValue

				self._cmdSendLine(`/processing/input/${ch}/eq/${band}/gain=${finalValue}`)

				if (typeof self._applyInputEQ === 'function') {
					self._applyInputEQ(ch, band, 'gain', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_eq_band${band}_gain`]: finalValue.toFixed(1),
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				self.log?.(
					'info',
					`Parametric EQ: Input ${ch}${inputName} Band ${band} gain ${currentValue.toFixed(1)} + ${delta.toFixed(1)} = ${finalValue.toFixed(1)} dB`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateEQCurrentValues === 'function') {
				self._updateEQCurrentValues()
			}
		},
	}

	actions['input_eq_knob_frequency'] = {
		name: 'Input: Parametric EQ Knob - Frequency',
		description:
			'Adjust frequency for the selected input(s) and band. Range: 10 Hz to 20 kHz. Octave-based acceleration adapts to current frequency for natural control.',
		options: [
			{
				type: 'number',
				id: 'delta',
				label: 'Delta (Hz) - for button press',
				default: 1,
				min: -20000,
				max: 20000,
				step: 0.01,
			},
		],
		callback: (e) => {
			const chs = self?._eqKnobControl?.selectedInputs || [1]
			const band = self?._eqKnobControl?.selectedBand || 1
			const defaultFreqs = { 1: 32, 2: 125, 3: 500, 4: 2000, 5: 8000 }
			let delta = Number(e.options.delta ?? 0)

			if (!self.inputEQ) self.inputEQ = {}

			for (const ch of chs) {
				if (!self.inputEQ[ch]) self.inputEQ[ch] = {}
				if (!self.inputEQ[ch][band]) self.inputEQ[ch][band] = {}

				const currentValue = Number(self.inputEQ[ch][band].frequency ?? defaultFreqs[band])

				// Time-based acceleration for rotary encoders with range-based tiers
				if (e.surfaceId !== undefined) {
					const now = Date.now()
					const accelKey = `eq_freq_${e.surfaceId || 'default'}`

					if (!self._rotaryAccel) self._rotaryAccel = {}

					const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
					const timeDiff = now - lastRotation.time

					// 4-tier acceleration based on rotation speed
					let speedTier = 0
					if (timeDiff < 100) {
						speedTier = Math.min(lastRotation.count + 1, 3)
					}

					self._rotaryAccel[accelKey] = { time: now, count: speedTier }

					// Octave-based acceleration tiers based on CURRENT frequency (4 tiers: 0, 1, 2, 3)
					// Organized by octave ranges for better musical/logarithmic control
					let deltaTiers
					if (currentValue < 31) {
						// 10-31 Hz (sub-bass): 0.5, 1, 2, 4 (faster)
						deltaTiers = [0.5, 1, 2, 4]
					} else if (currentValue < 63) {
						// 31-63 Hz: 1, 2, 5, 10 (faster)
						deltaTiers = [1, 2, 5, 10]
					} else if (currentValue < 125) {
						// 63-125 Hz: 2, 5, 10, 20 (faster)
						deltaTiers = [2, 5, 10, 20]
					} else if (currentValue < 250) {
						// 125-250 Hz: 5, 10, 20, 40 (faster)
						deltaTiers = [5, 10, 20, 40]
					} else if (currentValue < 500) {
						// 250-500 Hz: 10, 20, 50, 100 (faster)
						deltaTiers = [10, 20, 50, 100]
					} else if (currentValue < 1000) {
						// 500-1000 Hz: 20, 50, 100, 200 (faster)
						deltaTiers = [20, 50, 100, 200]
					} else if (currentValue < 2000) {
						// 1k-2k Hz: 50, 100, 200, 500 (faster)
						deltaTiers = [50, 100, 200, 500]
					} else if (currentValue < 4000) {
						// 2k-4k Hz: 100, 200, 500, 1000 (faster)
						deltaTiers = [100, 200, 500, 1000]
					} else if (currentValue < 8000) {
						// 4k-8k Hz: 200, 500, 1000, 2000 (faster)
						deltaTiers = [200, 500, 1000, 2000]
					} else if (currentValue < 16000) {
						// 8k-16k Hz: 500, 1000, 2000, 4000 (faster)
						deltaTiers = [500, 1000, 2000, 4000]
					} else {
						// 16k-20k Hz: 1000, 2000, 3000, 5000 (faster)
						deltaTiers = [1000, 2000, 3000, 5000]
					}
					delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
				}
				let newValue = currentValue + delta

				// Apply precision rules: 0.01 Hz below 100 Hz, 1 Hz above
				if (newValue < 100) {
					newValue = Math.round(newValue * 100) / 100 // 0.01 Hz precision
				} else {
					newValue = Math.round(newValue) // 1 Hz precision
				}

				const finalValue = Math.max(10, Math.min(20000, newValue))

				self.inputEQ[ch][band].frequency = finalValue

				self._cmdSendLine(`/processing/input/${ch}/eq/${band}/frequency=${finalValue}`)

				if (typeof self._applyInputEQ === 'function') {
					self._applyInputEQ(ch, band, 'frequency', finalValue)
				}

				// Update variable with appropriate precision
				if (typeof self.setVariableValues === 'function') {
					const freqStr = finalValue < 100 ? finalValue.toFixed(2) : Math.round(finalValue).toString()
					self.setVariableValues({
						[`input_${ch}_eq_band${band}_frequency`]: freqStr,
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				const currentStr = currentValue < 100 ? currentValue.toFixed(2) : Math.round(currentValue).toString()
				const finalStr = finalValue < 100 ? finalValue.toFixed(2) : Math.round(finalValue).toString()
				self.log?.(
					'info',
					`Parametric EQ: Input ${ch}${inputName} Band ${band} frequency ${currentStr} + ${delta} = ${finalStr} Hz`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateEQCurrentValues === 'function') {
				self._updateEQCurrentValues()
			}
		},
	}

	actions['input_eq_knob_bandwidth'] = {
		name: 'Input: Parametric EQ Knob - Bandwidth (Q)',
		description:
			'Adjust bandwidth/Q for the selected input(s) and band. Range: 0.1 to 2. Acceleration (3 tiers): 0.01 â†’ 0.05 â†’ 0.1 (precise).',
		options: [
			{
				type: 'number',
				id: 'delta',
				label: 'Delta - for button press',
				default: 0.01,
				min: -2,
				max: 2,
				step: 0.01,
			},
		],
		callback: (e) => {
			const chs = self?._eqKnobControl?.selectedInputs || [1]
			const band = self?._eqKnobControl?.selectedBand || 1
			let delta = Number(e.options.delta ?? 0)

			// Time-based acceleration for rotary encoders
			if (e.surfaceId !== undefined) {
				const now = Date.now()
				const accelKey = `eq_bw_${e.surfaceId || 'default'}`

				if (!self._rotaryAccel) self._rotaryAccel = {}

				const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
				const timeDiff = now - lastRotation.time

				// 4-tier acceleration based on rotation speed
				let speedTier = 0
				if (timeDiff < 100) {
					speedTier = Math.min(lastRotation.count + 1, 3)
				}

				self._rotaryAccel[accelKey] = { time: now, count: speedTier }

				// Acceleration tiers: 0 = 0.01, 1 = 0.05, 2 = 0.1, 3 = 0.2 (more precise)
				const deltaTiers = [0.01, 0.05, 0.1, 0.2]
				delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
			}

			if (!self.inputEQ) self.inputEQ = {}

			for (const ch of chs) {
				if (!self.inputEQ[ch]) self.inputEQ[ch] = {}
				if (!self.inputEQ[ch][band]) self.inputEQ[ch][band] = {}

				const currentValue = Number(self.inputEQ[ch][band].bandwidth ?? 1)
				const newValue = currentValue + delta
				const finalValue = Math.max(0.1, Math.min(2, Math.round(newValue * 100) / 100))

				self.inputEQ[ch][band].bandwidth = finalValue

				self._cmdSendLine(`/processing/input/${ch}/eq/${band}/bandwidth=${finalValue}`)

				if (typeof self._applyInputEQ === 'function') {
					self._applyInputEQ(ch, band, 'bandwidth', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_eq_band${band}_bandwidth`]: finalValue.toFixed(1),
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				self.log?.(
					'info',
					`Parametric EQ: Input ${ch}${inputName} Band ${band} bandwidth ${currentValue.toFixed(1)} + ${delta.toFixed(1)} = ${finalValue.toFixed(1)}`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateEQCurrentValues === 'function') {
				self._updateEQCurrentValues()
			}
		},
	}

	actions['input_eq_bypass'] = {
		name: 'Input: Parametric EQ Bypass (Master)',
		description: 'Bypass all parametric EQ bands for selected input(s).',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input channel(s)',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'mode',
				label: 'Mode',
				default: 'set',
				choices: [
					{ id: 'set', label: 'Set bypass state' },
					{ id: 'toggle', label: 'Toggle bypass' },
				],
			},
			{
				type: 'dropdown',
				id: 'state',
				label: 'Bypass state',
				default: 'true',
				choices: [
					{ id: 'true', label: 'Bypass ON' },
					{ id: 'false', label: 'Bypass OFF' },
				],
				isVisible: (o) => o.mode === 'set',
			},
		],
		callback: (e) => {
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			const mode = e.options.mode ?? 'set'

			for (const ch of chs) {
				let state
				if (mode === 'toggle') {
					const current = self?.inputEQ?.[ch]?.bypass
					state = !current
				} else {
					state = e.options.state === 'true'
				}

				self._cmdSendLine(`/processing/input/${ch}/eq/bypass=${state ? 'true' : 'false'}`)

				if (typeof self._applyInputEQBypass === 'function') {
					self._applyInputEQBypass(ch, state)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_eq_bypass`]: state ? 'ON' : 'OFF',
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				self.log?.('info', `Parametric EQ: Input ${ch}${inputName} bypass ${state ? 'ON' : 'OFF'}`)
			}
		},
	}

	actions['input_eq_band_bypass'] = {
		name: 'Input: Parametric EQ Band Bypass',
		description: 'Bypass individual EQ band for selected input(s).',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Input channel(s)',
				default: [],
				choices: inputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: 1,
				choices: [
					{ id: 1, label: 'Band 1' },
					{ id: 2, label: 'Band 2' },
					{ id: 3, label: 'Band 3' },
					{ id: 4, label: 'Band 4' },
					{ id: 5, label: 'Band 5' },
				],
			},
			{
				type: 'dropdown',
				id: 'mode',
				label: 'Mode',
				default: 'set',
				choices: [
					{ id: 'set', label: 'Set bypass state' },
					{ id: 'toggle', label: 'Toggle bypass' },
				],
			},
			{
				type: 'dropdown',
				id: 'state',
				label: 'Bypass state',
				default: 'true',
				choices: [
					{ id: 'true', label: 'Bypassed' },
					{ id: 'false', label: 'Enabled' },
				],
				isVisible: (o) => o.mode === 'set',
			},
		],
		callback: (e) => {
			const chs = safeGetChannels(e.options, 'chs', NUM_INPUTS)
			const band = Number(e.options.band ?? 1)
			const mode = e.options.mode ?? 'set'

			for (const ch of chs) {
				let state
				if (mode === 'toggle') {
					const current = self?.inputEQ?.[ch]?.[band]?.band_bypass
					state = !current
				} else {
					state = e.options.state === 'true'
				}

				self._cmdSendLine(`/processing/input/${ch}/eq/${band}/band_bypass=${state ? 'true' : 'false'}`)

				if (typeof self._applyInputEQ === 'function') {
					self._applyInputEQ(ch, band, 'band_bypass', state)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_eq_band${band}_bypass`]: state ? 'ON' : 'OFF',
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				self.log?.('info', `Parametric EQ: Input ${ch}${inputName} Band ${band} bypass ${state ? 'ON' : 'OFF'}`)
			}
		},
	}

	actions['input_eq_knob_band_bypass'] = {
		name: 'Input: Parametric EQ Band Bypass (Rotary)',
		description: 'Toggle Parametric EQ band bypass for selected input(s) and selected band. Push button action.',
		options: [],
		callback: () => {
			if (!self._eqKnobControl) return

			const chs = self._eqKnobControl.selectedInputs || [1]
			const band = self._eqKnobControl.selectedBand || 1

			// Parametric EQ has 5 bands for inputs
			if (band < 1 || band > 5) return

			for (const ch of chs) {
				if (ch < 1 || ch > NUM_INPUTS) continue

				// Initialize state if needed
				if (!self.inputEQ) self.inputEQ = {}
				if (!self.inputEQ[ch]) self.inputEQ[ch] = {}
				if (!self.inputEQ[ch][band]) self.inputEQ[ch][band] = {}

				// Get current bypass state (default to false if unknown)
				const currentBypass = self.inputEQ[ch][band].band_bypass || false
				const newBypass = !currentBypass

				// Send command to device
				self._cmdSendLine(`/processing/input/${ch}/eq/${band}/band_bypass=${newBypass}`)

				// Update internal state
				if (typeof self._applyInputEQ === 'function') {
					self._applyInputEQ(ch, band, 'band_bypass', newBypass)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`input_${ch}_eq_band${band}_bypass`]: newBypass ? 'ON' : 'OFF',
					})
				}

				const inputName = self?.inputName?.[ch] ? ` (${self.inputName[ch]})` : ''
				self.log?.(
					'info',
					`Parametric EQ: Input ${ch}${inputName} Band ${band} bypass ${currentBypass ? 'ON' : 'OFF'} â†’ ${newBypass ? 'ON' : 'OFF'}`,
				)
			}
		},
	}

	// =============================================
	// ===== OUTPUT U-SHAPING & PARAMETRIC EQ ======
	// =============================================

	actions['output_ushaping_select_output'] = {
		name: 'Output: U-Shaping Select Output Channel(s)',
		description: 'Select which output channel(s) the U-Shaping knobs will control (can select multiple to link them)',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: ['1'],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}

			// Store the selected output channels (array)
			if (!self._ushapingKnobControlOutput) self._ushapingKnobControlOutput = {}
			self._ushapingKnobControlOutput.selectedOutputs = chs

			// Update variable
			if (typeof self.setVariableValues === 'function') {
				const names = chs
					.map((ch) => {
						const name = self?.outputName?.[ch]
						return name ? `${ch} (${name})` : `${ch}`
					})
					.join(', ')

				self.setVariableValues({
					ushaping_selected_output: names,
					ushaping_selected_output_num: chs.join(','),
				})

				// Update dynamic current value variables
				if (typeof self._updateUShapingCurrentValues === 'function') {
					self._updateUShapingCurrentValues()
				}
			}

			// Update feedbacks
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('ushaping_output_selected')
			}

			const channelList = chs
				.map((ch) => {
					const name = self?.outputName?.[ch]
					return name ? `${ch} (${name})` : `${ch}`
				})
				.join(', ')

			self.log?.('info', `U-Shaping: Selected output(s): ${channelList}`)
		},
	}

	actions['output_ushaping_select_band'] = {
		name: 'Output: U-Shaping Select Band',
		description: 'Select which band (1-5) the U-Shaping knobs will control',
		options: [
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: '1',
				choices: [
					{ id: '1', label: 'Output U-Shaping Band 1' },
					{ id: '2', label: 'Output U-Shaping Band 2' },
					{ id: '3', label: 'Output U-Shaping Band 3' },
					{ id: '4', label: 'Output U-Shaping Band 4' },
					{ id: '5', label: 'Output U-Shaping Band 5' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const band = Number(e.options.band)
			if (!Number.isFinite(band) || band < 1 || band > 5) {
				self.log?.('warn', `Invalid band: ${e.options.band}`)
				return
			}

			// Store the selected band
			if (!self._ushapingKnobControlOutput) self._ushapingKnobControlOutput = {}
			self._ushapingKnobControlOutput.selectedBand = band

			// Update variable
			if (typeof self.setVariableValues === 'function') {
				const bandLabels = {
					1: 'Output U-Shaping Band 1',
					2: 'Output U-Shaping Band 2',
					3: 'Output U-Shaping Band 3',
					4: 'Output U-Shaping Band 4',
					5: 'Output U-Shaping Band 5',
				}
				self.setVariableValues({
					ushaping_selected_output_band: bandLabels[band],
					ushaping_selected_output_band_num: band,
				})

				// Update dynamic current value variables
				if (typeof self._updateUShapingOutputCurrentValues === 'function') {
					self._updateUShapingOutputCurrentValues()
				}
			}

			// Update feedbacks
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('ushaping_output_band_selected')
			}

			self.log?.('info', `U-Shaping: Selected Output Band ${band}`)
		},
	}

	actions['output_ushaping_bypass'] = {
		name: 'Output: U-Shaping Bypass',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Enabled' },
					{ id: 'off', label: 'Bypass' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const op = String(e.options.operation || 'toggle')
			for (const ch of chs) {
				let state
				if (op === 'toggle') {
					const current = self?.outputUShaping?.[ch]?.bypass
					const currentBool =
						typeof current === 'boolean' ? current : /^(true|1|on)$/i.test(String(current ?? '').trim())
					state = !currentBool
				} else {
					const enable = op === 'on'
					state = !enable
				}
				self._cmdSendLine(`/processing/output/${ch}/ushaping/bypass=${state ? 'true' : 'false'}`)
				if (typeof self._applyOutputUShapingBypass === 'function') {
					self._applyOutputUShapingBypass(ch, state)
				}
				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_ushaping_bypass`]: state ? 'ON' : 'OFF',
					})
				}
				self.log?.('info', `Output ch ${ch}: U-Shaping bypass ${state ? 'ON' : 'OFF'}`)
			}
		},
	}

	// U-Shaping Knob Control System - Knob Actions
	actions['output_ushaping_knob_gain'] = {
		name: 'Output: U-Shaping Knob - Gain',
		description: 'Adjust gain for the selected output(s) and band. Acceleration (3 tiers): 0.1 â†’ 0.3 â†’ 0.5 dB.',
		options: [
			{
				type: 'static-text',
				id: 'info',
				label: 'Selection',
				value: 'Uses currently selected output channel(s) and band. Use selection buttons to choose.',
			},
			{
				type: 'number',
				id: 'delta',
				label: 'Gain delta (dB) - for button press',
				default: 0.5,
				min: -15,
				max: 15,
				step: 0.1,
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const chs = self?._ushapingKnobControlOutput?.selectedOutputs || [1]
			const band = self?._ushapingKnobControlOutput?.selectedBand || 1
			let delta = Number(e.options.delta ?? 0)

			// Time-based acceleration for rotary encoders
			if (e.surfaceId !== undefined) {
				const now = Date.now()
				const accelKey = `ushaping_gain_${e.surfaceId || 'default'}`

				if (!self._rotaryAccel) self._rotaryAccel = {}

				const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
				const timeDiff = now - lastRotation.time

				// 4-tier acceleration based on rotation speed
				let speedTier = 0
				if (timeDiff < 100) {
					speedTier = Math.min(lastRotation.count + 1, 3)
				}

				self._rotaryAccel[accelKey] = { time: now, count: speedTier }

				// Acceleration tiers: 0 = 0.1dB, 1 = 0.5dB, 2 = 1dB, 3 = 2dB (faster)
				const deltaTiers = [0.1, 0.5, 1.0, 2.0]
				delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
			}

			// Initialize storage if needed
			if (!self.outputUShaping) self.outputUShaping = {}

			for (const ch of chs) {
				if (!self.outputUShaping[ch]) self.outputUShaping[ch] = {}
				if (!self.outputUShaping[ch][band]) self.outputUShaping[ch][band] = {}

				const currentValue = Number(self.outputUShaping[ch][band].gain ?? 0)
				const newValue = currentValue + delta
				const finalValue = Math.max(-15, Math.min(15, newValue))

				// Update internal state
				self.outputUShaping[ch][band].gain = finalValue

				self._cmdSendLine(`/processing/output/${ch}/ushaping/${band}/gain=${finalValue}`)

				if (typeof self._applyOutputUShaping === 'function') {
					self._applyOutputUShaping(ch, band, 'gain', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_ushaping_band${band}_gain`]: finalValue.toFixed(1),
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				const deltaStr = delta >= 0 ? `+${delta.toFixed(1)}` : delta.toFixed(1)
				self.log?.(
					'info',
					`U-Shaping: Output ${ch}${outputName} Band ${band} gain ${currentValue.toFixed(1)} ${deltaStr} = ${finalValue.toFixed(1)} dB`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateUShapingOutputCurrentValues === 'function') {
				self._updateUShapingOutputCurrentValues()
			}
		},
	}

	actions['output_ushaping_knob_frequency'] = {
		name: 'Output: U-Shaping Knob - Frequency',
		description:
			'Adjust frequency for the selected output(s) and band (B1: 20-2500Hz, B2: 40-5000Hz, B3: 80-10kHz, B4: 160-20kHz). Octave-based acceleration adapts to current frequency for natural control.',
		options: [
			{
				type: 'static-text',
				id: 'info',
				label: 'Selection',
				value: 'Uses currently selected output channel(s) and band. Band 5 (HF) does not have frequency.',
			},
			{
				type: 'number',
				id: 'delta',
				label: 'Frequency delta (Hz) - for button press',
				default: 10,
				min: -1000,
				max: 1000,
				step: 1,
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const chs = self?._ushapingKnobControlOutput?.selectedOutputs || [1]
			const band = self?._ushapingKnobControlOutput?.selectedBand || 1

			// Band 5 doesn't have frequency
			if (band === 5) {
				self.log?.('warn', 'U-Shaping: Band 5 (HF) does not have frequency parameter')
				return
			}

			// Band-specific frequency ranges
			const freqRanges = {
				1: { min: 20, max: 2500, default: 62 },
				2: { min: 40, max: 5000, default: 250 },
				3: { min: 80, max: 10000, default: 1000 },
				4: { min: 160, max: 20000, default: 4000 },
			}
			const range = freqRanges[band] || { min: 20, max: 20000, default: 1000 }

			// Initialize storage if needed
			if (!self.outputUShaping) self.outputUShaping = {}

			for (const ch of chs) {
				if (!self.outputUShaping[ch]) self.outputUShaping[ch] = {}
				if (!self.outputUShaping[ch][band]) self.outputUShaping[ch][band] = {}

				const currentValue = Number(self.outputUShaping[ch][band].frequency ?? range.default)
				let delta = Number(e.options.delta ?? 0)

				// Time-based acceleration for rotary encoders with range-based tiers
				if (e.surfaceId !== undefined) {
					const now = Date.now()
					const accelKey = `ushaping_freq_${e.surfaceId || 'default'}`

					if (!self._rotaryAccel) self._rotaryAccel = {}

					const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
					const timeDiff = now - lastRotation.time

					// 4-tier acceleration based on rotation speed
					let speedTier = 0
					if (timeDiff < 100) {
						speedTier = Math.min(lastRotation.count + 1, 3)
					}

					self._rotaryAccel[accelKey] = { time: now, count: speedTier }

					// Octave-based acceleration tiers based on CURRENT frequency (4 tiers: 0, 1, 2, 3)
					// Organized by octave ranges for better musical/logarithmic control
					let deltaTiers
					if (currentValue < 31) {
						// 10-31 Hz (sub-bass): 0.5, 1, 2, 4 (faster)
						deltaTiers = [0.5, 1, 2, 4]
					} else if (currentValue < 63) {
						// 31-63 Hz: 1, 2, 5, 10 (faster)
						deltaTiers = [1, 2, 5, 10]
					} else if (currentValue < 125) {
						// 63-125 Hz: 2, 5, 10, 20 (faster)
						deltaTiers = [2, 5, 10, 20]
					} else if (currentValue < 250) {
						// 125-250 Hz: 5, 10, 20, 40 (faster)
						deltaTiers = [5, 10, 20, 40]
					} else if (currentValue < 500) {
						// 250-500 Hz: 10, 20, 50, 100 (faster)
						deltaTiers = [10, 20, 50, 100]
					} else if (currentValue < 1000) {
						// 500-1000 Hz: 20, 50, 100, 200 (faster)
						deltaTiers = [20, 50, 100, 200]
					} else if (currentValue < 2000) {
						// 1k-2k Hz: 50, 100, 200, 500 (faster)
						deltaTiers = [50, 100, 200, 500]
					} else if (currentValue < 4000) {
						// 2k-4k Hz: 100, 200, 500, 1000 (faster)
						deltaTiers = [100, 200, 500, 1000]
					} else if (currentValue < 8000) {
						// 4k-8k Hz: 200, 500, 1000, 2000 (faster)
						deltaTiers = [200, 500, 1000, 2000]
					} else if (currentValue < 16000) {
						// 8k-16k Hz: 500, 1000, 2000, 4000 (faster)
						deltaTiers = [500, 1000, 2000, 4000]
					} else {
						// 16k-20k Hz: 1000, 2000, 3000, 5000 (faster)
						deltaTiers = [1000, 2000, 3000, 5000]
					}
					delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
				}
				const newValue = currentValue + delta
				const finalValue = Math.max(range.min, Math.min(range.max, newValue))

				// Update internal state
				self.outputUShaping[ch][band].frequency = finalValue

				self._cmdSendLine(`/processing/output/${ch}/ushaping/${band}/frequency=${finalValue}`)

				if (typeof self._applyOutputUShaping === 'function') {
					self._applyOutputUShaping(ch, band, 'frequency', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_ushaping_band${band}_frequency`]: Math.round(finalValue).toString(),
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				const deltaStr = delta >= 0 ? `+${delta}` : delta
				self.log?.(
					'info',
					`U-Shaping: Output ${ch}${outputName} Band ${band} frequency ${currentValue} ${deltaStr} = ${finalValue} Hz`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateUShapingOutputCurrentValues === 'function') {
				self._updateUShapingOutputCurrentValues()
			}
		},
	}

	actions['output_ushaping_knob_slope'] = {
		name: 'Output: U-Shaping Knob - Slope (dB/oct)',
		description:
			'Cycle through slope values for the selected output(s) and band (6, 12, 18, 24, 30, 36, 42, 48 dB/oct). Acceleration (3 tiers): 1 â†’ 2 â†’ 3 steps.',
		options: [
			{
				type: 'static-text',
				id: 'info',
				label: 'Selection',
				value: 'Uses currently selected output channel(s) and band (all bands including Band 5).',
			},
			{
				type: 'dropdown',
				id: 'direction',
				label: 'Direction - for button press',
				default: 'up',
				choices: [
					{ id: 'up', label: 'Cycle Up (6â†’12â†’18â†’...)' },
					{ id: 'down', label: 'Cycle Down (...â†’18â†’12â†’6)' },
				],
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const chs = self?._ushapingKnobControlOutput?.selectedOutputs || [1]
			const band = self?._ushapingKnobControlOutput?.selectedBand || 1

			// Determine direction and step count
			let direction = e.options.direction || 'up'
			let stepCount = 1

			// Time-based acceleration for rotary encoders
			if (e.surfaceId !== undefined) {
				const now = Date.now()
				const accelKey = `ushaping_slope_${e.surfaceId || 'default'}`

				if (!self._rotaryAccel) self._rotaryAccel = {}

				const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
				const timeDiff = now - lastRotation.time

				// 4-tier acceleration based on rotation speed
				let speedTier = 0
				if (timeDiff < 100) {
					speedTier = Math.min(lastRotation.count + 1, 3)
				}

				self._rotaryAccel[accelKey] = { time: now, count: speedTier }

				// Acceleration tiers: 0 = 1 step, 1 = 2 steps, 2 = 3 steps, 3 = 4 steps
				const stepTiers = [1, 2, 3, 4]
				stepCount = stepTiers[speedTier]
			}

			// Available slope values: 6, 12, 18, 24, 30, 36, 42, 48 dB/oct
			const slopeValues = [6, 12, 18, 24, 30, 36, 42, 48]

			// Initialize storage if needed
			if (!self.outputUShaping) self.outputUShaping = {}

			for (const ch of chs) {
				if (!self.outputUShaping[ch]) self.outputUShaping[ch] = {}
				if (!self.outputUShaping[ch][band]) self.outputUShaping[ch][band] = {}

				const currentValue = Number(self.outputUShaping[ch][band].slope ?? 12)

				// Find closest slope value to current
				let currentIndex = 0
				let minDiff = Math.abs(slopeValues[0] - currentValue)
				for (let i = 1; i < slopeValues.length; i++) {
					const diff = Math.abs(slopeValues[i] - currentValue)
					if (diff < minDiff) {
						minDiff = diff
						currentIndex = i
					}
				}

				// Move to next or previous value by stepCount
				let newIndex
				if (direction === 'up') {
					newIndex = (currentIndex + stepCount) % slopeValues.length
				} else {
					newIndex = (currentIndex - stepCount + slopeValues.length) % slopeValues.length
				}
				const finalValue = slopeValues[newIndex]

				// Update internal state
				self.outputUShaping[ch][band].slope = finalValue

				self._cmdSendLine(`/processing/output/${ch}/ushaping/${band}/slope=${finalValue}`)

				if (typeof self._applyOutputUShaping === 'function') {
					self._applyOutputUShaping(ch, band, 'slope', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_ushaping_band${band}_slope`]: Math.round(finalValue).toString(),
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				self.log?.(
					'info',
					`U-Shaping: Output ${ch}${outputName} Band ${band} slope ${currentValue} dB/oct â†’ ${finalValue} dB/oct`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateUShapingOutputCurrentValues === 'function') {
				self._updateUShapingOutputCurrentValues()
			}
		},
	}

	actions['output_ushaping_knob_band_bypass'] = {
		name: 'Output: U-Shaping Band Bypass (Rotary)',
		description: 'Toggle U-Shaping band bypass for selected output(s) and selected band. Push button action.',
		options: [],
		callback: () => {
			if (!self._ushapingKnobControlOutput) return

			const chs = self._ushapingKnobControlOutput.selectedOutputs || [1]
			const band = self._ushapingKnobControlOutput.selectedBand || 1

			// U-Shaping has 5 bands
			if (band < 1 || band > 5) return

			for (const ch of chs) {
				if (ch < 1 || ch > NUM_OUTPUTS) continue

				// Initialize state if needed
				if (!self.outputUShaping) self.outputUShaping = {}
				if (!self.outputUShaping[ch]) self.outputUShaping[ch] = {}
				if (!self.outputUShaping[ch][band]) self.outputUShaping[ch][band] = {}

				// Get current bypass state (default to false if unknown)
				const currentBypass = self.outputUShaping[ch][band].band_bypass || false
				const newBypass = !currentBypass

				// Send command to device
				self._cmdSendLine(`/processing/output/${ch}/ushaping/${band}/band_bypass=${newBypass}`)

				// Update internal state
				self.outputUShaping[ch][band].band_bypass = newBypass

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_ushaping_band${band}_bypass`]: newBypass ? 'ON' : 'OFF',
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				self.log?.(
					'info',
					`U-Shaping: Output ${ch}${outputName} Band ${band} bypass ${currentBypass ? 'ON' : 'OFF'} â†’ ${newBypass ? 'ON' : 'OFF'}`,
				)
			}
		},
	}

	// ===== Output Parametric EQ (knob-based selection) =====

	actions['output_eq_select_output'] = {
		name: 'Output: Parametric EQ Select Output Channel(s)',
		description:
			'Select which output channel(s) the Parametric EQ knobs will control. Multiple channels can be linked together.',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: ['1'],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
		],
		callback: (e) => {
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (!self._eqKnobControlOutput) self._eqKnobControlOutput = {}
			self._eqKnobControlOutput.selectedOutputs = chs

			// Update variables to show selected outputs
			const names = chs
				.map((ch) => {
					const nm = self?.outputName?.[ch]
					return nm ? `Output ${ch} (${nm})` : `Output ${ch}`
				})
				.join(', ')

			if (typeof self.setVariableValues === 'function') {
				self.setVariableValues({
					eq_selected_output: names,
					eq_selected_output_num: chs.join(','),
				})

				// Update dynamic current value variables
				if (typeof self._updateEQCurrentValues === 'function') {
					self._updateEQCurrentValues()
				}
			}

			// Update feedbacks if they exist
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('eq_output_selected')
			}
		},
	}

	actions['output_eq_select_band'] = {
		name: 'Output: Parametric EQ Select Band',
		description: 'Select which band (1-10) the Parametric EQ knobs will control.',
		options: [
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: 1,
				choices: [
					{ id: 1, label: 'Output PEQ Band 1' },
					{ id: 2, label: 'Output PEQ Band 2' },
					{ id: 3, label: 'Output PEQ Band 3' },
					{ id: 4, label: 'Output PEQ Band 4' },
					{ id: 5, label: 'Output PEQ Band 5' },
					{ id: 6, label: 'Output PEQ Band 6' },
					{ id: 7, label: 'Output PEQ Band 7' },
					{ id: 8, label: 'Output PEQ Band 8' },
					{ id: 9, label: 'Output PEQ Band 9' },
					{ id: 10, label: 'Output PEQ Band 10' },
				],
			},
		],
		callback: (e) => {
			const band = Number(e.options.band ?? 1)
			if (!self._eqKnobControlOutput) self._eqKnobControlOutput = {}
			self._eqKnobControlOutput.selectedBand = band

			const bandLabels = {
				1: 'Output PEQ Band 1',
				2: 'Output PEQ Band 2',
				3: 'Output PEQ Band 3',
				4: 'Output PEQ Band 4',
				5: 'Output PEQ Band 5',
				6: 'Output PEQ Band 6',
				7: 'Output PEQ Band 7',
				8: 'Output PEQ Band 8',
				9: 'Output PEQ Band 9',
				10: 'Output PEQ Band 10',
			}

			if (typeof self.setVariableValues === 'function') {
				self.setVariableValues({
					eq_selected_output_band: bandLabels[band],
					eq_selected_output_band_num: band,
				})

				// Update dynamic current value variables
				if (typeof self._updateEQOutputCurrentValues === 'function') {
					self._updateEQOutputCurrentValues()
				}
			}

			// Update feedbacks if they exist
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('eq_output_band_selected')
			}
		},
	}

	actions['output_eq_knob_gain'] = {
		name: 'Output: Parametric EQ Knob - Gain',
		description:
			'Adjust gain for the selected output(s) and band. Range: -18 to +18 dB. Acceleration (3 tiers): 0.1 â†’ 0.5 â†’ 1 dB.',
		options: [
			{
				type: 'number',
				id: 'delta',
				label: 'Delta (dB) - for button press',
				default: 0.1,
				min: -18,
				max: 18,
				step: 0.1,
			},
		],
		callback: (e) => {
			const chs = self?._eqKnobControlOutput?.selectedOutputs || [1]
			const band = self?._eqKnobControlOutput?.selectedBand || 1
			let delta = Number(e.options.delta ?? 0)

			// Time-based acceleration for rotary encoders
			if (e.surfaceId !== undefined) {
				const now = Date.now()
				const accelKey = `eq_gain_${e.surfaceId || 'default'}`

				if (!self._rotaryAccel) self._rotaryAccel = {}

				const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
				const timeDiff = now - lastRotation.time

				// 4-tier acceleration based on rotation speed
				let speedTier = 0
				if (timeDiff < 100) {
					speedTier = Math.min(lastRotation.count + 1, 3)
				}

				self._rotaryAccel[accelKey] = { time: now, count: speedTier }

				// Acceleration tiers: 0 = 0.1dB, 1 = 0.5dB, 2 = 1dB, 3 = 2dB (faster)
				const deltaTiers = [0.1, 0.5, 1.0, 2.0]
				delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
			}

			if (!self.outputEQ) self.outputEQ = {}

			for (const ch of chs) {
				if (!self.outputEQ[ch]) self.outputEQ[ch] = {}
				if (!self.outputEQ[ch][band]) self.outputEQ[ch][band] = {}

				const currentValue = Number(self.outputEQ[ch][band].gain ?? 0)
				const newValue = currentValue + delta
				const finalValue = Math.max(-18, Math.min(18, newValue))

				self.outputEQ[ch][band].gain = finalValue

				self._cmdSendLine(`/processing/output/${ch}/eq/${band}/gain=${finalValue}`)

				if (typeof self._applyOutputEQ === 'function') {
					self._applyOutputEQ(ch, band, 'gain', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_eq_band${band}_gain`]: finalValue.toFixed(1),
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				self.log?.(
					'info',
					`Parametric EQ: Output ${ch}${outputName} Band ${band} gain ${currentValue.toFixed(1)} + ${delta.toFixed(1)} = ${finalValue.toFixed(1)} dB`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateEQOutputCurrentValues === 'function') {
				self._updateEQOutputCurrentValues()
			}
		},
	}

	actions['output_eq_knob_frequency'] = {
		name: 'Output: Parametric EQ Knob - Frequency',
		description:
			'Adjust frequency for the selected output(s) and band. Range: 10 Hz to 20 kHz. Octave-based acceleration adapts to current frequency for natural control.',
		options: [
			{
				type: 'number',
				id: 'delta',
				label: 'Delta (Hz) - for button press',
				default: 1,
				min: -20000,
				max: 20000,
				step: 0.01,
			},
		],
		callback: (e) => {
			const chs = self?._eqKnobControlOutput?.selectedOutputs || [1]
			const band = self?._eqKnobControlOutput?.selectedBand || 1
			const defaultFreqs = { 1: 32, 2: 125, 3: 500, 4: 2000, 5: 8000, 6: 63, 7: 250, 8: 1000, 9: 4000, 10: 16000 }
			let delta = Number(e.options.delta ?? 0)

			if (!self.outputEQ) self.outputEQ = {}

			for (const ch of chs) {
				if (!self.outputEQ[ch]) self.outputEQ[ch] = {}
				if (!self.outputEQ[ch][band]) self.outputEQ[ch][band] = {}

				const currentValue = Number(self.outputEQ[ch][band].frequency ?? defaultFreqs[band])

				// Time-based acceleration for rotary encoders with range-based tiers
				if (e.surfaceId !== undefined) {
					const now = Date.now()
					const accelKey = `eq_freq_${e.surfaceId || 'default'}`

					if (!self._rotaryAccel) self._rotaryAccel = {}

					const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
					const timeDiff = now - lastRotation.time

					// 4-tier acceleration based on rotation speed
					let speedTier = 0
					if (timeDiff < 100) {
						speedTier = Math.min(lastRotation.count + 1, 3)
					}

					self._rotaryAccel[accelKey] = { time: now, count: speedTier }

					// Octave-based acceleration tiers based on CURRENT frequency (4 tiers: 0, 1, 2, 3)
					// Organized by octave ranges for better musical/logarithmic control
					let deltaTiers
					if (currentValue < 31) {
						// 10-31 Hz (sub-bass): 0.5, 1, 2, 4 (faster)
						deltaTiers = [0.5, 1, 2, 4]
					} else if (currentValue < 63) {
						// 31-63 Hz: 1, 2, 5, 10 (faster)
						deltaTiers = [1, 2, 5, 10]
					} else if (currentValue < 125) {
						// 63-125 Hz: 2, 5, 10, 20 (faster)
						deltaTiers = [2, 5, 10, 20]
					} else if (currentValue < 250) {
						// 125-250 Hz: 5, 10, 20, 40 (faster)
						deltaTiers = [5, 10, 20, 40]
					} else if (currentValue < 500) {
						// 250-500 Hz: 10, 20, 50, 100 (faster)
						deltaTiers = [10, 20, 50, 100]
					} else if (currentValue < 1000) {
						// 500-1000 Hz: 20, 50, 100, 200 (faster)
						deltaTiers = [20, 50, 100, 200]
					} else if (currentValue < 2000) {
						// 1k-2k Hz: 50, 100, 200, 500 (faster)
						deltaTiers = [50, 100, 200, 500]
					} else if (currentValue < 4000) {
						// 2k-4k Hz: 100, 200, 500, 1000 (faster)
						deltaTiers = [100, 200, 500, 1000]
					} else if (currentValue < 8000) {
						// 4k-8k Hz: 200, 500, 1000, 2000 (faster)
						deltaTiers = [200, 500, 1000, 2000]
					} else if (currentValue < 16000) {
						// 8k-16k Hz: 500, 1000, 2000, 4000 (faster)
						deltaTiers = [500, 1000, 2000, 4000]
					} else {
						// 16k-20k Hz: 1000, 2000, 3000, 5000 (faster)
						deltaTiers = [1000, 2000, 3000, 5000]
					}
					delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
				}
				let newValue = currentValue + delta

				// Apply precision rules: 0.01 Hz below 100 Hz, 1 Hz above
				if (newValue < 100) {
					newValue = Math.round(newValue * 100) / 100 // 0.01 Hz precision
				} else {
					newValue = Math.round(newValue) // 1 Hz precision
				}

				const finalValue = Math.max(10, Math.min(20000, newValue))

				self.outputEQ[ch][band].frequency = finalValue

				self._cmdSendLine(`/processing/output/${ch}/eq/${band}/frequency=${finalValue}`)

				if (typeof self._applyOutputEQ === 'function') {
					self._applyOutputEQ(ch, band, 'frequency', finalValue)
				}

				// Update variable with appropriate precision
				if (typeof self.setVariableValues === 'function') {
					const freqStr = finalValue < 100 ? finalValue.toFixed(2) : Math.round(finalValue).toString()
					self.setVariableValues({
						[`output_${ch}_eq_band${band}_frequency`]: freqStr,
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				const currentStr = currentValue < 100 ? currentValue.toFixed(2) : Math.round(currentValue).toString()
				const finalStr = finalValue < 100 ? finalValue.toFixed(2) : Math.round(finalValue).toString()
				self.log?.(
					'info',
					`Parametric EQ: Output ${ch}${outputName} Band ${band} frequency ${currentStr} + ${delta} = ${finalStr} Hz`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateEQOutputCurrentValues === 'function') {
				self._updateEQOutputCurrentValues()
			}
		},
	}

	actions['output_eq_knob_bandwidth'] = {
		name: 'Output: Parametric EQ Knob - Bandwidth (Q)',
		description:
			'Adjust bandwidth/Q for the selected output(s) and band. Range: 0.1 to 2. Acceleration (3 tiers): 0.01 â†’ 0.05 â†’ 0.1 (precise).',
		options: [
			{
				type: 'number',
				id: 'delta',
				label: 'Delta - for button press',
				default: 0.01,
				min: -2,
				max: 2,
				step: 0.01,
			},
		],
		callback: (e) => {
			const chs = self?._eqKnobControlOutput?.selectedOutputs || [1]
			const band = self?._eqKnobControlOutput?.selectedBand || 1
			let delta = Number(e.options.delta ?? 0)

			// Time-based acceleration for rotary encoders
			if (e.surfaceId !== undefined) {
				const now = Date.now()
				const accelKey = `eq_bw_${e.surfaceId || 'default'}`

				if (!self._rotaryAccel) self._rotaryAccel = {}

				const lastRotation = self._rotaryAccel[accelKey] || { time: 0, count: 0 }
				const timeDiff = now - lastRotation.time

				// 4-tier acceleration based on rotation speed
				let speedTier = 0
				if (timeDiff < 100) {
					speedTier = Math.min(lastRotation.count + 1, 3)
				}

				self._rotaryAccel[accelKey] = { time: now, count: speedTier }

				// Acceleration tiers: 0 = 0.01, 1 = 0.05, 2 = 0.1, 3 = 0.2 (more precise)
				const deltaTiers = [0.01, 0.05, 0.1, 0.2]
				delta = deltaTiers[speedTier] * (delta >= 0 ? 1 : -1)
			}

			if (!self.outputEQ) self.outputEQ = {}

			for (const ch of chs) {
				if (!self.outputEQ[ch]) self.outputEQ[ch] = {}
				if (!self.outputEQ[ch][band]) self.outputEQ[ch][band] = {}

				const currentValue = Number(self.outputEQ[ch][band].bandwidth ?? 1)
				const newValue = currentValue + delta
				const finalValue = Math.max(0.1, Math.min(2, Math.round(newValue * 100) / 100))

				self.outputEQ[ch][band].bandwidth = finalValue

				self._cmdSendLine(`/processing/output/${ch}/eq/${band}/bandwidth=${finalValue}`)

				if (typeof self._applyOutputEQ === 'function') {
					self._applyOutputEQ(ch, band, 'bandwidth', finalValue)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_eq_band${band}_bandwidth`]: finalValue.toFixed(1),
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				self.log?.(
					'info',
					`Parametric EQ: Output ${ch}${outputName} Band ${band} bandwidth ${currentValue.toFixed(1)} + ${delta.toFixed(1)} = ${finalValue.toFixed(1)}`,
				)
			}

			// Immediately update dynamic current value display
			if (typeof self._updateEQOutputCurrentValues === 'function') {
				self._updateEQOutputCurrentValues()
			}
		},
	}

	actions['output_eq_bypass'] = {
		name: 'Output: Parametric EQ Bypass (Master)',
		description: 'Bypass all parametric EQ bands for selected output(s).',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'mode',
				label: 'Mode',
				default: 'set',
				choices: [
					{ id: 'set', label: 'Set bypass state' },
					{ id: 'toggle', label: 'Toggle bypass' },
				],
			},
			{
				type: 'dropdown',
				id: 'state',
				label: 'Bypass state',
				default: 'true',
				choices: [
					{ id: 'true', label: 'Bypassed' },
					{ id: 'false', label: 'Enabled' },
				],
				isVisible: (o) => o.mode === 'set',
			},
		],
		callback: (e) => {
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			const mode = e.options.mode ?? 'set'

			for (const ch of chs) {
				let state
				if (mode === 'toggle') {
					const current = self?.outputEQ?.[ch]?.bypass
					state = !current
				} else {
					state = e.options.state === 'true'
				}

				self._cmdSendLine(`/processing/output/${ch}/eq/bypass=${state ? 'true' : 'false'}`)

				if (typeof self._applyOutputEQBypass === 'function') {
					self._applyOutputEQBypass(ch, state)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_eq_bypass`]: state ? 'ON' : 'OFF',
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				self.log?.('info', `Parametric EQ: Output ${ch}${outputName} bypass ${state ? 'ON' : 'OFF'}`)
			}
		},
	}

	actions['output_eq_band_bypass'] = {
		name: 'Output: Parametric EQ Band Bypass',
		description: 'Bypass individual EQ band for selected output(s).',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: 1,
				choices: [
					{ id: 1, label: 'Band 1' },
					{ id: 2, label: 'Band 2' },
					{ id: 3, label: 'Band 3' },
					{ id: 4, label: 'Band 4' },
					{ id: 5, label: 'Band 5' },
					{ id: 6, label: 'Band 6' },
					{ id: 7, label: 'Band 7' },
					{ id: 8, label: 'Band 8' },
					{ id: 9, label: 'Band 9' },
					{ id: 10, label: 'Band 10' },
				],
			},
			{
				type: 'dropdown',
				id: 'mode',
				label: 'Mode',
				default: 'set',
				choices: [
					{ id: 'set', label: 'Set bypass state' },
					{ id: 'toggle', label: 'Toggle bypass' },
				],
			},
			{
				type: 'dropdown',
				id: 'state',
				label: 'Bypass state',
				default: 'true',
				choices: [
					{ id: 'true', label: 'Bypassed' },
					{ id: 'false', label: 'Enabled' },
				],
				isVisible: (o) => o.mode === 'set',
			},
		],
		callback: (e) => {
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			const band = Number(e.options.band ?? 1)
			const mode = e.options.mode ?? 'set'

			for (const ch of chs) {
				let state
				if (mode === 'toggle') {
					const current = self?.outputEQ?.[ch]?.[band]?.band_bypass
					state = !current
				} else {
					state = e.options.state === 'true'
				}

				self._cmdSendLine(`/processing/output/${ch}/eq/${band}/band_bypass=${state ? 'true' : 'false'}`)

				if (typeof self._applyOutputEQ === 'function') {
					self._applyOutputEQ(ch, band, 'band_bypass', state)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_eq_band${band}_bypass`]: state ? 'ON' : 'OFF',
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				self.log?.('info', `Parametric EQ: Output ${ch}${outputName} Band ${band} bypass ${state ? 'ON' : 'OFF'}`)
			}
		},
	}

	actions['output_eq_knob_band_bypass'] = {
		name: 'Output: Parametric EQ Band Bypass (Rotary)',
		description: 'Toggle Parametric EQ band bypass for selected output(s) and selected band. Push button action.',
		options: [],
		callback: () => {
			if (!self._eqKnobControlOutput) return

			const chs = self._eqKnobControlOutput.selectedOutputs || [1]
			const band = self._eqKnobControlOutput.selectedBand || 1

			// Parametric EQ has 10 bands for outputs
			if (band < 1 || band > 10) return

			for (const ch of chs) {
				if (ch < 1 || ch > NUM_OUTPUTS) continue

				// Initialize state if needed
				if (!self.outputEQ) self.outputEQ = {}
				if (!self.outputEQ[ch]) self.outputEQ[ch] = {}
				if (!self.outputEQ[ch][band]) self.outputEQ[ch][band] = {}

				// Get current bypass state (default to false if unknown)
				const currentBypass = self.outputEQ[ch][band].band_bypass || false
				const newBypass = !currentBypass

				// Send command to device
				self._cmdSendLine(`/processing/output/${ch}/eq/${band}/band_bypass=${newBypass}`)

				// Update internal state
				if (typeof self._applyOutputEQ === 'function') {
					self._applyOutputEQ(ch, band, 'band_bypass', newBypass)
				}

				// Update variable
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({
						[`output_${ch}_eq_band${band}_bypass`]: newBypass ? 'ON' : 'OFF',
					})
				}

				const outputName = self?.outputName?.[ch] ? ` (${self.outputName[ch]})` : ''
				self.log?.(
					'info',
					`Parametric EQ: Output ${ch}${outputName} Band ${band} bypass ${currentBypass ? 'ON' : 'OFF'} â†’ ${newBypass ? 'ON' : 'OFF'}`,
				)
			}
		},
	}

	actions['output_gain_set'] = {
		name: 'Output: Set gain (dB)',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'target',
				label: 'Set to',
				default: 'value',
				choices: [
					{ id: 'value', label: 'Specific dB value' },
					{ id: 'last', label: 'Last dB value' },
				],
			},
			{
				type: 'number',
				id: 'gain',
				label: 'Gain (dB)',
				default: 0,
				min: -90,
				max: 10,
				step: 0.1,
				isVisible: (o) => o.target === 'value',
			},
			{ type: 'number', id: 'fadeMs', label: 'Fade duration (ms)', default: 0, min: 0, max: 600000, step: 10 },
			{
				type: 'dropdown',
				id: 'curve',
				label: 'Curve (used if fading)',
				default: 'linear',
				choices: [
					{ id: 'linear', label: 'Linear (dB)' },
					{ id: 'log', label: 'Logarithmic' },
				],
			},
			{
				type: 'checkbox',
				id: 'rememberPrev',
				label: 'Remember previous per channel',
				default: true,
				isVisible: () => false,
			},
			{
				type: 'checkbox',
				id: 'revertInstead',
				label: 'Revert to previously remembered value',
				default: false,
				isVisible: () => false,
			},
		],

		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const dur = Math.max(0, Number(e.options.fadeMs) || 0)
			const curve = e.options.curve === 'log' ? 'log' : 'linear'
			const btnId = e?.controlId || e?.event?.controlId || null

			const target = (e.options && e.options.target === 'last') || e.options?.revertInstead === true ? 'last' : 'value'
			const wantRemember = e.options && e.options.rememberPrev !== false

			for (const ch of chs) {
				if (target === 'last') {
					const prev = typeof self._getPrevOutputGain === 'function' ? self._getPrevOutputGain(ch, btnId) : null
					if (prev == null) {
						self.log?.('info', `Output ch ${ch}: no previous gain stored; revert skipped`)
						continue
					}
					if (dur > 0 && typeof self._startOutputGainFade === 'function') {
						self._startOutputGainFade(ch, prev, dur, curve)
					} else if (typeof self._setOutputGain === 'function') {
						self._setOutputGain(ch, prev)
					}
					continue
				}

				const g = Number(e.options.gain)
				if (!Number.isFinite(g)) continue

				if (wantRemember) {
					if (typeof self._subWrite === 'function') {
						self._subWrite(`/processing/output/${ch}/gain`)
					}
					if (typeof self._beginPrevCaptureWindow === 'function') {
						self._beginPrevCaptureWindow('output', ch, btnId, 300)
					}
					if (typeof self._rememberPrevOutputGain === 'function') {
						self._rememberPrevOutputGain(ch, btnId)
					}
				}

				if (dur > 0 && typeof self._startOutputGainFade === 'function') {
					self._startOutputGainFade(ch, g, dur, curve)
				} else if (typeof self._setOutputGain === 'function') {
					self._setOutputGain(ch, g)
				}
			}
		},
	}

	actions['output_gain_revert'] = {
		name: 'Output: Revert to previous gain',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{ type: 'number', id: 'fadeMs', label: 'Fade duration (ms)', default: 0, min: 0, max: 600000, step: 10 },
			{
				type: 'dropdown',
				id: 'curve',
				label: 'Curve (used if fading)',
				default: 'linear',
				choices: [
					{ id: 'linear', label: 'Linear (dB)' },
					{ id: 'log', label: 'Logarithmic' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const dur = Math.max(0, Number(e.options.fadeMs) || 0)
			const curve = e.options.curve === 'log' ? 'log' : 'linear'
			const btnId = e?.controlId || e?.event?.controlId || null

			for (const ch of chs) {
				const prev = typeof self._getPrevOutputGain === 'function' ? self._getPrevOutputGain(ch, btnId) : null
				if (prev == null) {
					self.log?.('info', `Output ch ${ch}: no previous gain stored; revert skipped`)
					continue
				}
				if (dur > 0 && typeof self._startOutputGainFade === 'function') {
					self._startOutputGainFade(ch, prev, dur, curve)
				} else if (typeof self._setOutputGain === 'function') {
					self._setOutputGain(ch, prev)
				}
			}
		},
	}

	actions['output_polarity_control'] = {
		name: 'Output: Polarity reversal',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Set to Reversed' },
					{ id: 'off', label: 'Set to Normal' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}

			const op = e.options?.operation || 'toggle'

			for (const ch of chs) {
				if (op === 'toggle') {
					if (typeof self._toggleOutputPolarity === 'function') {
						self._toggleOutputPolarity(ch)
					} else {
						const current = !!self?.outputPolarity?.[ch]
						const next = !current
						if (typeof self._cmdSendLine === 'function') {
							self._cmdSendLine(`/processing/output/${ch}/polarity_reversal=${next ? 'true' : 'false'}`)
						}
						if (typeof self._applyOutputPolarity === 'function') {
							self._applyOutputPolarity(ch, next)
						} else if (self?.outputPolarity) {
							self.outputPolarity[ch] = next
							if (typeof self.setVariableValues === 'function') {
								self.setVariableValues({ [`output_${ch}_polarity`]: next ? 'Reverse' : 'Normal' })
							}
						}
					}
					continue
				}

				const want = op === 'on'
				if (typeof self._setOutputPolarity === 'function') {
					self._setOutputPolarity(ch, want)
				} else {
					if (typeof self._cmdSendLine === 'function') {
						self._cmdSendLine(`/processing/output/${ch}/polarity_reversal=${want ? 'true' : 'false'}`)
					}
					if (typeof self._applyOutputPolarity === 'function') {
						self._applyOutputPolarity(ch, want)
					} else if (self?.outputPolarity) {
						self.outputPolarity[ch] = want
						if (typeof self.setVariableValues === 'function') {
							self.setVariableValues({ [`output_${ch}_polarity`]: want ? 'Reverse' : 'Normal' })
						}
					}
				}
			}
		},
	}

	actions['output_delay_set'] = {
		name: 'Output: Set delay (ms)',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{ type: 'number', id: 'ms', label: 'Delay (ms)', default: 0, min: 0, max: 2000, step: 0.01 },
			{ type: 'checkbox', id: 'relative', label: 'Add to current delay (relative)', default: false },
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const wantRelative = !!e.options.relative
			const reqMs = Number(e.options.ms)
			const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v))
			const roundTo01 = (v) => Math.round(v / 0.01) * 0.01

			for (const ch of chs) {
				let targetMs = clamp(Number.isFinite(reqMs) ? reqMs : 0, 0, 2000)
				if (wantRelative) {
					const curMs = Number(self?.outputDelay?.[ch]?.ms)
					if (Number.isFinite(curMs)) targetMs = curMs + targetMs
				}
				targetMs = roundTo01(targetMs)

				if (typeof self._setOutputDelayMs === 'function') {
					self._setOutputDelayMs(ch, targetMs)
				} else if (typeof self._cmdSendLine === 'function') {
					const samples = Math.round(targetMs * 96)
					self._cmdSendLine(`/processing/output/${ch}/delay=${samples}`)
					if (typeof self._applyOutputDelay === 'function') {
						self._applyOutputDelay(ch, samples)
					}
				}
			}
		},
	}

	actions['output_product_integration_set'] = {
		name: 'Output: Set product integration',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'speaker',
				label: 'Loudspeaker',
				default: 'OFF',
				choices: productIntegrationSpeakerChoices,
			},
			...productIntegrationPhaseOptionDefs,
			...productIntegrationStartingPointOptionDefs,
			{
				type: 'checkbox',
				id: 'mixed_array_compensation',
				label: 'Apply mixed array compensation',
				tooltip: (o) => {
					const speakerKey = String(o.speaker || '')
					const compensation = STARTING_POINTS_SOURCE.compensation || {}
					const compData = compensation[speakerKey]
					if (compData?.label) {
						return `${compData.label} (${compData.delayMs} ms)`
					}
					return 'Apply delay compensation for mixed arrays'
				},
				default: false,
				isVisible: (o) => {
					const speakerKey = String(o.speaker || '')
					// Only show for LEO, LEOPARD, or MINA
					return (
						speakerKey === 'LEO' ||
						speakerKey === 'LEOPARD' ||
						speakerKey === 'MINA'
					)
				},
			},
			{
				type: 'checkbox',
				id: 'reset_channel',
				label: 'Reset channel to factory defaults before applying',
				default: false,
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}

			const speakerKey = String(e.options?.speaker || 'OFF')
			const phaseOptionId = productIntegrationSpeakerPhaseGroup.get(speakerKey)
			let requestedPhase = ''
			if (phaseOptionId) {
				requestedPhase = String(e.options?.[phaseOptionId] || '')
			}
			let typeId = null

			if (speakerKey === 'OFF') {
				typeId = productIntegrationLookup.get('OFF|') || '1'
			} else {
				const speakerEntry = productIntegrationSpeakers.get(speakerKey)
				let phaseKey = requestedPhase
				if ((!phaseKey || phaseKey === '') && speakerEntry?.phases?.[0]?.id) {
					phaseKey = speakerEntry.phases[0].id
				}

				if (typeof phaseKey === 'string' && phaseKey.length > 0) {
					typeId = productIntegrationLookup.get(`${speakerKey}|${phaseKey}`)
					if (!typeId && speakerEntry?.phases) {
						const exact = speakerEntry.phases.find((p) => p.id === phaseKey)
						if (exact?.typeId) typeId = exact.typeId
					}
				}

				if (!typeId && speakerEntry?.phases?.length > 0) {
					const fallbackPhase = speakerEntry.phases[0]
					phaseKey = fallbackPhase?.id ?? ''
					typeId = fallbackPhase?.typeId ?? null
				}
			}

			if (!typeId) {
				self.log?.('warn', `Invalid product integration selection for speaker ${speakerKey}`)
				return
			}

			let startingPointCommands = null
			let startingPointTitle = ''
			if (speakerKey !== 'OFF') {
				const startingOptionId = productIntegrationSpeakerStartingPointOption.get(speakerKey)
				if (startingOptionId) {
					const selectionId = String(e.options?.[startingOptionId] ?? '').trim()
					if (selectionId) {
						const entries = productIntegrationStartingPoints.get(speakerKey) || []
						const entry = entries.find((sp) => sp.id === selectionId)
						if (entry && Array.isArray(entry.controlPoints) && entry.controlPoints.length > 0) {
							startingPointCommands = entry.controlPoints
							startingPointTitle = entry.title || ''
						}
					}
				}
			}

			const finalTypeId = String(typeId)
			const shouldReset = e.options.reset_channel === true

			for (const ch of chs) {
				// Apply factory reset if checkbox is enabled
				if (shouldReset) {
					for (const resetCmd of FACTORY_RESET_COMMANDS) {
						const cmd = resetCmd.replace(/\{ch\}/g, ch)
						self._cmdSendLine(cmd)
					}
				}

				// Apply product integration type
				self._cmdSendLine(`/processing/output/${ch}/delay_integration/type=${finalTypeId}`)

				// Apply starting point commands if any
				if (startingPointCommands && startingPointCommands.length) {
					for (const rawCmd of startingPointCommands) {
						let cmd = String(rawCmd || '').trim()
						if (!cmd) continue
						if (cmd.includes('{}')) {
							cmd = cmd.replace(/\{\}/g, ch)
						} else if (cmd.includes('{ch}')) {
							cmd = cmd.replace(/\{ch\}/gi, ch)
						}
						self._cmdSendLine(cmd)
					}
				}

				// Apply mixed array compensation if enabled
				if (e.options.mixed_array_compensation === true) {
					const compensation = STARTING_POINTS_SOURCE.compensation || {}
					const compData = compensation[speakerKey]
					if (compData && typeof compData.delayMs === 'number') {
						const compensationMs = compData.delayMs
						// Get current delay and add compensation
						const currentDelayObj = self?.outputDelay?.[ch]
						const currentDelayMs = currentDelayObj?.ms || 0
						const currentDelaySamples = currentDelayObj?.samples || 0
						const totalDelayMs = currentDelayMs + compensationMs
						const totalSamples = Math.round(totalDelayMs * 96)
						self.log?.(
							'info',
							`Ch ${ch}: Applying compensation: current=${currentDelayMs.toFixed(2)}ms (${currentDelaySamples} samples) + ${compensationMs.toFixed(2)}ms = ${totalDelayMs.toFixed(2)}ms (${totalSamples} samples) | Command: /processing/output/${ch}/delay=${totalSamples}`,
						)
						if (typeof self._setOutputDelayMs === 'function') {
							self._setOutputDelayMs(ch, totalDelayMs)
						}
					}
				}
			}

			// Log the operation
			const resetMsg = shouldReset ? ' (with factory reset)' : ''
			let compensationMsg = ''
			if (e.options.mixed_array_compensation === true) {
				const compensation = STARTING_POINTS_SOURCE.compensation || {}
				const compData = compensation[speakerKey]
				if (compData && typeof compData.delayMs === 'number') {
					compensationMsg = ` with ${compData.delayMs.toFixed(2)} ms mixed array compensation`
				}
			}
			if (startingPointCommands && startingPointTitle) {
				self.log?.(
					'info',
					`Applied starting point "${startingPointTitle}" for speaker ${speakerKey} on outputs ${chs.join(', ')}${resetMsg}${compensationMsg}`,
				)
			} else if (shouldReset || compensationMsg) {
				self.log?.(
					'info',
					`Applied product integration for speaker ${speakerKey} on outputs ${chs.join(', ')}${resetMsg}${compensationMsg}`,
				)
			}
		},
	}

	actions['output_highpass_bypass'] = {
		name: 'Output: High-pass bypass control',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Enabled' },
					{ id: 'off', label: 'Bypassed' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const op = String(e.options?.operation || 'toggle')
			for (const ch of chs) {
				if (op === 'toggle') {
					if (typeof self._toggleOutputHighpassBypass === 'function') {
						self._toggleOutputHighpassBypass(ch)
					} else if (typeof self._setOutputHighpassBypass === 'function') {
						const current = !!self?.outputHighpass?.[ch]?.bypass
						self._setOutputHighpassBypass(ch, !current)
					} else {
						const current = !!self?.outputHighpass?.[ch]?.bypass
						const next = !current
						if (typeof self._cmdSendLine === 'function') {
							self._cmdSendLine(`/processing/output/${ch}/highpass/bypass=${next ? 'true' : 'false'}`)
						}
						if (typeof self._applyOutputFilter === 'function') {
							self._applyOutputFilter('highpass', ch, 'bypass', next)
						}
					}
					continue
				}

				const wantEngaged = op === 'Enabled'
				const bypass = !wantEngaged
				if (typeof self._setOutputHighpassBypass === 'function') {
					self._setOutputHighpassBypass(ch, bypass)
				} else {
					if (typeof self._cmdSendLine === 'function') {
						self._cmdSendLine(`/processing/output/${ch}/highpass/bypass=${bypass ? 'true' : 'false'}`)
					}
					if (typeof self._applyOutputFilter === 'function') {
						self._applyOutputFilter('highpass', ch, 'bypass', bypass)
					}
				}
			}
		},
	}

	actions['output_highpass_frequency'] = {
		name: 'Output: High-pass frequency',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'number',
				id: 'frequency',
				label: 'Frequency (Hz)',
				default: 40,
				min: 5,
				max: 20000,
				step: 1,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const hz = Number(e.options?.frequency)
			if (!Number.isFinite(hz)) {
				self.log?.('warn', 'Invalid high-pass frequency')
				return
			}
			for (const ch of chs) {
				if (typeof self._setOutputHighpassFrequency === 'function') {
					self._setOutputHighpassFrequency(ch, hz)
				} else {
					const clamped = Math.max(5, Math.min(20000, hz))
					if (typeof self._cmdSendLine === 'function') {
						self._cmdSendLine(`/processing/output/${ch}/highpass/frequency=${clamped}`)
					}
					if (typeof self._applyOutputFilter === 'function') {
						self._applyOutputFilter('highpass', ch, 'frequency', clamped)
					}
				}
			}
		},
	}

	actions['output_highpass_type'] = {
		name: 'Output: High-pass type',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'type',
				label: 'Filter type',
				default: '11',
				choices: FILTER_TYPE_CHOICES_HP,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const typeId = Number(e.options?.type)
			if (!Number.isFinite(typeId)) {
				self.log?.('warn', 'Invalid high-pass type selection')
				return
			}
			const rounded = Math.max(1, Math.min(12, Math.round(typeId)))
			for (const ch of chs) {
				if (typeof self._setOutputHighpassType === 'function') {
					self._setOutputHighpassType(ch, rounded)
				} else {
					if (typeof self._cmdSendLine === 'function') {
						self._cmdSendLine(`/processing/output/${ch}/highpass/type=${rounded}`)
					}
					if (typeof self._applyOutputFilter === 'function') {
						self._applyOutputFilter('highpass', ch, 'type', rounded)
					}
				}
			}
		},
	}

	actions['output_highpass_configure'] = {
		name: 'Output: High-pass configure',
		description: 'Set high-pass filter state, frequency, and type in one action.',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'state',
				label: 'Filter state',
				default: 'on',
				choices: [
					{ id: 'on', label: 'Enabled' },
					{ id: 'off', label: 'Bypassed' },
				],
			},
			{
				type: 'number',
				id: 'frequency',
				label: 'Frequency (Hz)',
				default: 40,
				min: 5,
				max: 20000,
				step: 1,
			},
			{
				type: 'dropdown',
				id: 'type',
				label: 'Filter type',
				default: '11',
				choices: FILTER_TYPE_CHOICES_HP,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}

			const engage = String(e.options?.state || 'on') === 'on'
			const bypass = !engage

			const hzRaw = Number(e.options?.frequency)
			const hz = Number.isFinite(hzRaw) ? Math.max(5, Math.min(20000, hzRaw)) : null

			const typeIdRaw = Number(e.options?.type)
			const typeId = Number.isFinite(typeIdRaw) ? Math.max(1, Math.min(12, Math.round(typeIdRaw))) : null

			for (const ch of chs) {
				if (hz !== null) {
					if (typeof self._setOutputHighpassFrequency === 'function') {
						self._setOutputHighpassFrequency(ch, hz)
					} else {
						if (typeof self._cmdSendLine === 'function')
							self._cmdSendLine(`/processing/output/${ch}/highpass/frequency=${hz}`)
						if (typeof self._applyOutputFilter === 'function') self._applyOutputFilter('highpass', ch, 'frequency', hz)
					}
				}

				if (typeId !== null) {
					if (typeof self._setOutputHighpassType === 'function') {
						self._setOutputHighpassType(ch, typeId)
					} else {
						if (typeof self._cmdSendLine === 'function')
							self._cmdSendLine(`/processing/output/${ch}/highpass/type=${typeId}`)
						if (typeof self._applyOutputFilter === 'function') self._applyOutputFilter('highpass', ch, 'type', typeId)
					}
				}

				if (typeof self._setOutputHighpassBypass === 'function') {
					self._setOutputHighpassBypass(ch, bypass)
				} else {
					if (typeof self._cmdSendLine === 'function')
						self._cmdSendLine(`/processing/output/${ch}/highpass/bypass=${bypass ? 'true' : 'false'}`)
					if (typeof self._applyOutputFilter === 'function') self._applyOutputFilter('highpass', ch, 'bypass', bypass)
				}
			}
		},
	}

	actions['output_lowpass_bypass'] = {
		name: 'Output: Low-pass bypass control',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Enabled' },
					{ id: 'off', label: 'Bypassed' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const op = String(e.options?.operation || 'toggle')
			for (const ch of chs) {
				if (op === 'toggle') {
					if (typeof self._toggleOutputLowpassBypass === 'function') {
						self._toggleOutputLowpassBypass(ch)
					} else if (typeof self._setOutputLowpassBypass === 'function') {
						const current = !!self?.outputLowpass?.[ch]?.bypass
						self._setOutputLowpassBypass(ch, !current)
					} else {
						const current = !!self?.outputLowpass?.[ch]?.bypass
						const next = !current
						if (typeof self._cmdSendLine === 'function') {
							self._cmdSendLine(`/processing/output/${ch}/lowpass/bypass=${next ? 'true' : 'false'}`)
						}
						if (typeof self._applyOutputFilter === 'function') {
							self._applyOutputFilter('lowpass', ch, 'bypass', next)
						}
					}
					continue
				}

				const wantEngaged = op === 'on'
				const bypass = !wantEngaged
				if (typeof self._setOutputLowpassBypass === 'function') {
					self._setOutputLowpassBypass(ch, bypass)
				} else {
					if (typeof self._cmdSendLine === 'function') {
						self._cmdSendLine(`/processing/output/${ch}/lowpass/bypass=${bypass ? 'true' : 'false'}`)
					}
					if (typeof self._applyOutputFilter === 'function') {
						self._applyOutputFilter('lowpass', ch, 'bypass', bypass)
					}
				}
			}
		},
	}

	actions['output_lowpass_frequency'] = {
		name: 'Output: Low-pass frequency',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'number',
				id: 'frequency',
				label: 'Frequency (Hz)',
				default: 160,
				min: 10,
				max: 20000,
				step: 1,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const hz = Number(e.options?.frequency)
			if (!Number.isFinite(hz)) {
				self.log?.('warn', 'Invalid low-pass frequency')
				return
			}
			for (const ch of chs) {
				if (typeof self._setOutputLowpassFrequency === 'function') {
					self._setOutputLowpassFrequency(ch, hz)
				} else {
					const clamped = Math.max(10, Math.min(20000, hz))
					if (typeof self._cmdSendLine === 'function') {
						self._cmdSendLine(`/processing/output/${ch}/lowpass/frequency=${clamped}`)
					}
					if (typeof self._applyOutputFilter === 'function') {
						self._applyOutputFilter('lowpass', ch, 'frequency', clamped)
					}
				}
			}
		},
	}

	actions['output_lowpass_type'] = {
		name: 'Output: Low-pass type',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'type',
				label: 'Filter type',
				default: '11',
				choices: FILTER_TYPE_CHOICES_LP,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const typeId = Number(e.options?.type)
			if (!Number.isFinite(typeId)) {
				self.log?.('warn', 'Invalid low-pass type selection')
				return
			}
			const rounded = Math.max(1, Math.min(11, Math.round(typeId)))
			for (const ch of chs) {
				if (typeof self._setOutputLowpassType === 'function') {
					self._setOutputLowpassType(ch, rounded)
				} else {
					if (typeof self._cmdSendLine === 'function') {
						self._cmdSendLine(`/processing/output/${ch}/lowpass/type=${rounded}`)
					}
					if (typeof self._applyOutputFilter === 'function') {
						self._applyOutputFilter('lowpass', ch, 'type', rounded)
					}
				}
			}
		},
	}

	actions['output_lowpass_configure'] = {
		name: 'Output: Low-pass configure',
		description: 'Set low-pass filter state, frequency, and type in one action.',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'state',
				label: 'Filter state',
				default: 'on',
				choices: [
					{ id: 'on', label: 'Enabled' },
					{ id: 'off', label: 'Bypassed' },
				],
			},
			{
				type: 'number',
				id: 'frequency',
				label: 'Frequency (Hz)',
				default: 160,
				min: 10,
				max: 20000,
				step: 1,
			},
			{
				type: 'dropdown',
				id: 'type',
				label: 'Filter type',
				default: '11',
				choices: FILTER_TYPE_CHOICES_LP,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}

			const engage = String(e.options?.state || 'on') === 'on'
			const bypass = !engage

			const hzRaw = Number(e.options?.frequency)
			const hz = Number.isFinite(hzRaw) ? Math.max(10, Math.min(20000, hzRaw)) : null

			const typeIdRaw = Number(e.options?.type)
			const typeId = Number.isFinite(typeIdRaw) ? Math.max(1, Math.min(11, Math.round(typeIdRaw))) : null

			for (const ch of chs) {
				if (hz !== null) {
					if (typeof self._setOutputLowpassFrequency === 'function') {
						self._setOutputLowpassFrequency(ch, hz)
					} else {
						if (typeof self._cmdSendLine === 'function')
							self._cmdSendLine(`/processing/output/${ch}/lowpass/frequency=${hz}`)
						if (typeof self._applyOutputFilter === 'function') self._applyOutputFilter('lowpass', ch, 'frequency', hz)
					}
				}

				if (typeId !== null) {
					if (typeof self._setOutputLowpassType === 'function') {
						self._setOutputLowpassType(ch, typeId)
					} else {
						if (typeof self._cmdSendLine === 'function')
							self._cmdSendLine(`/processing/output/${ch}/lowpass/type=${typeId}`)
						if (typeof self._applyOutputFilter === 'function') self._applyOutputFilter('lowpass', ch, 'type', typeId)
					}
				}

				if (typeof self._setOutputLowpassBypass === 'function') {
					self._setOutputLowpassBypass(ch, bypass)
				} else {
					if (typeof self._cmdSendLine === 'function')
						self._cmdSendLine(`/processing/output/${ch}/lowpass/bypass=${bypass ? 'true' : 'false'}`)
					if (typeof self._applyOutputFilter === 'function') self._applyOutputFilter('lowpass', ch, 'bypass', bypass)
				}
			}
		},
	}

	actions['output_allpass_bypass'] = {
		name: 'Output: All-pass bypass control',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
			},
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: '1',
				choices: ALLPASS_BAND_CHOICES,
			},
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Enabled' },
					{ id: 'off', label: 'Bypassed' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const band = Math.max(1, Math.min(3, Number(e.options?.band ?? 1)))
			const op = String(e.options?.operation || 'toggle')
			for (const ch of chs) {
				if (op === 'toggle') {
					if (typeof self._toggleOutputAllpassBypass === 'function') {
						self._toggleOutputAllpassBypass(ch, band)
					} else {
						const current = !!self?.outputAllpass?.[ch]?.[band]?.band_bypass
						const next = !current
						if (typeof self._cmdSendLine === 'function')
							self._cmdSendLine(`/processing/output/${ch}/allpass/${band}/band_bypass=${next ? 'true' : 'false'}`)
						if (typeof self._applyOutputAllpass === 'function') self._applyOutputAllpass(ch, band, 'band_bypass', next)
					}
					continue
				}
				const bypass = op !== 'on'
				if (typeof self._setOutputAllpassBypass === 'function') {
					self._setOutputAllpassBypass(ch, band, bypass)
				} else {
					if (typeof self._cmdSendLine === 'function')
						self._cmdSendLine(`/processing/output/${ch}/allpass/${band}/band_bypass=${bypass ? 'true' : 'false'}`)
					if (typeof self._applyOutputAllpass === 'function') self._applyOutputAllpass(ch, band, 'band_bypass', bypass)
				}
			}
		},
	}

	actions['output_allpass_frequency'] = {
		name: 'Output: All-pass frequency',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 1,
			},
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: '1',
				choices: ALLPASS_BAND_CHOICES,
			},
			{
				type: 'number',
				id: 'frequency',
				label: 'Frequency (Hz)',
				default: 100,
				min: 10,
				max: 20000,
				step: 1,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const band = Math.max(1, Math.min(3, Number(e.options?.band ?? 1)))
			const hz = Number(e.options?.frequency)
			if (!Number.isFinite(hz)) {
				self.log?.('warn', 'Invalid all-pass frequency')
				return
			}
			const clamped = Math.max(10, Math.min(20000, hz))
			for (const ch of chs) {
				if (typeof self._setOutputAllpassFrequency === 'function') {
					self._setOutputAllpassFrequency(ch, band, clamped)
				} else {
					if (typeof self._cmdSendLine === 'function')
						self._cmdSendLine(`/processing/output/${ch}/allpass/${band}/frequency=${clamped}`)
					if (typeof self._applyOutputAllpass === 'function') self._applyOutputAllpass(ch, band, 'frequency', clamped)
				}
			}
		},
	}

	actions['output_allpass_q'] = {
		name: 'Output: All-pass Q',
		options: [
			{
				type: 'multidropdown',
				id: 'chs',
				label: 'Output channel(s)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 1,
			},
			{
				type: 'dropdown',
				id: 'band',
				label: 'Band',
				default: '1',
				choices: ALLPASS_BAND_CHOICES,
			},
			{
				type: 'number',
				id: 'q',
				label: 'Q value',
				default: 1,
				min: 0.5,
				max: 10,
				step: 0.01,
			},
		],
		callback: (e) => {
			if (!self) return
			const chs = safeGetChannels(e.options, 'chs', NUM_OUTPUTS)
			if (chs.length === 0) {
				self.log?.('warn', 'No valid output channels selected')
				return
			}
			const band = Math.max(1, Math.min(3, Number(e.options?.band ?? 1)))
			const qRaw = Number(e.options?.q)
			if (!Number.isFinite(qRaw)) {
				self.log?.('warn', 'Invalid all-pass Q value')
				return
			}
			const clamped = Math.max(0.5, Math.min(10, qRaw))
			for (const ch of chs) {
				if (typeof self._setOutputAllpassQ === 'function') {
					self._setOutputAllpassQ(ch, band, clamped)
				} else {
					if (typeof self._cmdSendLine === 'function')
						self._cmdSendLine(`/processing/output/${ch}/allpass/${band}/q=${clamped}`)
					if (typeof self._applyOutputAllpass === 'function') self._applyOutputAllpass(ch, band, 'q', clamped)
				}
			}
		},
	}

	// =========================
	// ===== MATRIX (multi) ====
	// =========================

	const matrixInputChoices = buildMatrixInputChoices(self)
	const matrixOutputChoices = buildMatrixOutputChoices(self, NUM_OUTPUTS)

	actions['matrix_gain_set_multi'] = {
		name: 'Matrix: Set gain',
		options: [
			{
				type: 'multidropdown',
				id: 'mi',
				label: 'Matrix input(s)',
				default: [],
				choices: matrixInputChoices,
				minSelection: 0,
			},
			{
				type: 'multidropdown',
				id: 'mo',
				label: 'Matrix output(s)',
				default: [],
				choices: matrixOutputChoices,
				minSelection: 0,
			},
			{ type: 'number', id: 'gain', label: 'Gain (dB)', default: 0, min: -90, max: 10, step: 0.1 },
			{ type: 'number', id: 'fadeMs', label: 'Fade duration (ms)', default: 0, min: 0, max: 600000, step: 10 },
			{
				type: 'dropdown',
				id: 'curve',
				label: 'Curve (used if fading)',
				default: 'linear',
				choices: [
					{ id: 'linear', label: 'Linear (dB)' },
					{ id: 'log', label: 'Logarithmic' },
				],
			},
		],
		callback: (e) => {
			if (!self) return
			const dur = Math.max(0, Number(e.options.fadeMs) || 0)
			const curve = e.options.curve === 'log' ? 'log' : 'linear'
			const inputs = safeGetChannels(e.options, 'mi', 32)
			const outs = safeGetChannels(e.options, 'mo', NUM_OUTPUTS)
			if (inputs.length === 0 || outs.length === 0) {
				self.log?.('warn', 'No valid matrix channels selected')
				return
			}
			const gain = Number.isFinite(Number(e.options.gain)) ? Number(e.options.gain) : 0
			for (const i of inputs) {
				if (dur > 0 && typeof self._startMatrixGainFadeMulti === 'function') {
					self._startMatrixGainFadeMulti(i, outs, gain, dur, curve)
				} else if (typeof self._setMatrixGainMulti === 'function') {
					self._setMatrixGainMulti(i, outs, gain)
				}
			}
		},
	}

	actions['matrix_gain_nudge_multi'] = {
		name: 'Matrix: Nudge gain',
		options: [
			{
				type: 'multidropdown',
				id: 'mi',
				label: 'Matrix input(s)',
				default: [],
				choices: matrixInputChoices,
				minSelection: 0,
			},
			{
				type: 'multidropdown',
				id: 'mo',
				label: 'Matrix output(s)',
				default: [],
				choices: matrixOutputChoices,
				minSelection: 0,
			},
			{ type: 'number', id: 'delta', label: 'Delta (dB)', default: 1, min: -30, max: 30, step: 0.1 },
		],
		callback: (e) => {
			if (!self) return
			const inputs = safeGetChannels(e.options, 'mi', 32)
			const outs = safeGetChannels(e.options, 'mo', NUM_OUTPUTS)
			if (inputs.length === 0 || outs.length === 0) {
				self.log?.('warn', 'No valid matrix channels selected')
				return
			}
			const d = Number(e.options.delta)
			for (const i of inputs) {
				if (typeof self._nudgeMatrixGainMulti === 'function') {
					self._nudgeMatrixGainMulti(i, outs, d)
				}
			}
		},
	}

	// =========================
	// ===== Speaker test ======
	// =========================
	actions['output_chase_start'] = {
		name: 'Speaker test: Start',
		options: [
			{ type: 'dropdown', id: 'start', label: 'First output', default: '1', choices: outputChoicesFriendly },
			{
				type: 'dropdown',
				id: 'end',
				label: 'Last output',
				default: String(Math.min(8, NUM_OUTPUTS)),
				choices: outputChoicesFriendly,
			},
			{
				type: 'dropdown',
				id: 'delay',
				label: 'Delay per step',
				default: '1000',
				choices: [
					{ id: '250', label: '0.25 s' },
					{ id: '500', label: '0.5 s' },
					{ id: '1000', label: '1 s' },
					{ id: '2000', label: '2 s' },
					{ id: '3000', label: '3 s' },
					{ id: '5000', label: '5 s' },
					{ id: '10000', label: '10 s' },
					{ id: '10000', label: '15 s' },

				],
			},
			{
				type: 'dropdown',
				id: 'window',
				label: 'Speakers at a time',
				default: '1',
				choices: [
					{ id: '1', label: '1 (solo)' },
					{ id: '2', label: '2 (solo->pair->advance)' },
				],
			},
			{ type: 'checkbox', id: 'loop', label: 'Loop sequence', default: false },
		],
		callback: (e) => {
			if (!self || typeof self._startOutputChase !== 'function') return
			self._startOutputChase(
				Number(e.options.start),
				Number(e.options.end),
				Number(e.options.delay),
				Number(e.options.window),
				!!e.options.loop,
				e?.controlId || e?.event?.controlId || null,
			)
		},
	}

	actions['output_chase_stop'] = {
		name: 'Speaker test: Stop',
		options: [],
		callback: () => {
			if (!self || typeof self._stopOutputChase !== 'function') return
			self._stopOutputChase()
		},
	}

	// =========================
	// ===== AVB connect =======
	// =========================
	actions['connect_avb_input'] = {
		name: 'AVB: Connect input stream',
		options: [
			{
				type: 'dropdown',
				id: 'input',
				label: 'Galaxy input / matrix input',
				default: '1',
				choices: buildMatrixInputChoices(self),
			},
			{ type: 'textinput', id: 'groupP', label: 'Primary group', default: 'HQ.Audio' },
			{ type: 'textinput', id: 'entityP', label: 'Primary entity', default: 'GX 1 L' },
			{ type: 'number', id: 'idxP', label: 'Primary index', default: 0, min: 0, max: 999, step: 1 },
			{ type: 'number', id: 'chanP', label: 'Primary channel', default: 0, min: 0, max: 999, step: 1 },
			{ type: 'textinput', id: 'groupS', label: 'Secondary group', default: 'HQ.Audio' },
			{ type: 'textinput', id: 'entityS', label: 'Secondary entity', default: 'GX 1 L' },
			{ type: 'number', id: 'idxS', label: 'Secondary index', default: 0, min: 0, max: 999, step: 1 },
			{ type: 'number', id: 'chanS', label: 'Secondary channel', default: 0, min: 0, max: 999, step: 1 },
		],
		callback: (e) => {
			if (!self || typeof self._sendConnectAvbInput !== 'function') return
			self._sendConnectAvbInput({
				input: Number(e.options.input),
				groupP: e.options.groupP,
				entityP: e.options.entityP,
				streamIndexP: e.options.idxP,
				streamChanP: e.options.chanP,
				groupS: e.options.groupS,
				entityS: e.options.entityS,
				streamIndexS: e.options.idxS,
				streamChanS: e.options.chanS,
			})
		},
	}

	// =========================
	// ======= SIM bus =========
	// =========================

	const simProbeChoices = [
		{ id: '0', label: 'input post source select' },
		{ id: '1', label: 'input post processing' },
		{ id: '2', label: 'output post matrix' },
		{ id: '4', label: 'output post eq' },
		{ id: '5', label: 'output post processing' },
		{ id: '6', label: 'output post fir' },
	]
	const isInputPoint = (id) => id === '0' || id === '1'
	const validSimPoints = new Set(simProbeChoices.map((c) => c.id))

	actions['sim_enable_and_configure'] = {
		name: 'SIM: enable/disable + configure (console & processor)',
		options: [
			{
				type: 'checkbox',
				id: 'consoleEnable',
				label: 'console SIM bus enabled',
				default: true,
			},
			{
				type: 'dropdown',
				id: 'consolePoint',
				label: 'console probe point',
				default: '0',
				choices: simProbeChoices,
			},
			{
				type: 'dropdown',
				id: 'consoleChannelIn',
				label: 'console channel',
				default: '1',
				choices: buildInputChoices(self, NUM_INPUTS),
				isVisible: (o) => isInputPoint(String(nn(o?.consolePoint, '0'))),
			},
			{
				type: 'dropdown',
				id: 'consoleChannelOut',
				label: 'console channel',
				default: '1',
				choices: buildOutputChoices(self, NUM_OUTPUTS),
				isVisible: (o) => !isInputPoint(String(nn(o?.consolePoint, '0'))),
			},
			{
				type: 'checkbox',
				id: 'processorEnable',
				label: 'processor SIM bus enabled',
				default: true,
			},
			{
				type: 'dropdown',
				id: 'processorPoint',
				label: 'processor probe point',
				default: '0',
				choices: simProbeChoices,
			},
			{
				type: 'dropdown',
				id: 'processorChannelIn',
				label: 'processor channel',
				default: '1',
				choices: buildInputChoices(self, NUM_INPUTS),
				isVisible: (o) => isInputPoint(String(nn(o?.processorPoint, '0'))),
			},
			{
				type: 'dropdown',
				id: 'processorChannelOut',
				label: 'processor channel',
				default: '1',
				choices: buildOutputChoices(self, NUM_OUTPUTS),
				isVisible: (o) => !isInputPoint(String(nn(o?.processorPoint, '0'))),
			},
		],

		callback: (e) => {
			if (!self) return

			const pConsoleRaw = String(nn(e.options.consolePoint, '0'))
			const pConsole = validSimPoints.has(pConsoleRaw) ? pConsoleRaw : '0'
			const consoleEnabled = !!e.options.consoleEnable

			let chConsole = 1
			if (isInputPoint(pConsole)) {
				chConsole = Math.max(1, Math.min(NUM_INPUTS, Number(nn(e.options.consoleChannelIn, 1))))
			} else {
				chConsole = Math.max(1, Math.min(NUM_OUTPUTS, Number(nn(e.options.consoleChannelOut, 1))))
			}

			const pProcessorRaw = String(nn(e.options.processorPoint, '0'))
			const pProcessor = validSimPoints.has(pProcessorRaw) ? pProcessorRaw : '0'
			const processorEnabled = !!e.options.processorEnable

			let chProcessor = 1
			if (isInputPoint(pProcessor)) {
				chProcessor = Math.max(1, Math.min(NUM_INPUTS, Number(nn(e.options.processorChannelIn, 1))))
			} else {
				chProcessor = Math.max(1, Math.min(NUM_OUTPUTS, Number(nn(e.options.processorChannelOut, 1))))
			}

			const cmds = [
				`/device/sim/mute_relay/1=${consoleEnabled ? 'false' : 'true'}`,
				`/device/sim/mute_relay/2=${processorEnabled ? 'false' : 'true'}`,
				`/device/sim/probe/1/point=${pConsole}`,
				`/device/sim/probe/1/channel=${chConsole}`,
				`/device/sim/probe/2/point=${pProcessor}`,
				`/device/sim/probe/2/channel=${chProcessor}`,
			]

			if (typeof self._cmdSendBatch === 'function') {
				self._cmdSendBatch(cmds)
			} else if (typeof self._cmdSendLine === 'function') {
				cmds.forEach((c) => self._cmdSendLine(c))
			}

			const labelByPoint = {
				0: 'input post source select',
				1: 'input post processing',
				2: 'output post matrix',
				4: 'output post eq',
				5: 'output post processing',
				6: 'output post fir',
			}
			const inNm = (ch) => (self?.inputName?.[ch] ? ` - ${self.inputName[ch]}` : '')
			const outNm = (ch) => (self?.outputName?.[ch] ? ` - ${self.outputName[ch]}` : '')
			const consoleName = isInputPoint(pConsole) ? inNm(chConsole) : outNm(chConsole)
			const processorName = isInputPoint(pProcessor) ? inNm(chProcessor) : outNm(chProcessor)

			self.log?.(
				'info',
				[
					`SIM console: ${consoleEnabled ? 'enabled' : 'disabled'} (relay=${consoleEnabled ? 'false' : 'true'}), point=${pConsole} (${labelByPoint[pConsole]}), ch=${chConsole}${consoleName}`,
					`SIM processor: ${processorEnabled ? 'enabled' : 'disabled'} (relay=${processorEnabled ? 'false' : 'true'}), point=${pProcessor} (${labelByPoint[pProcessor]}), ch=${chProcessor}${processorName}`,
				].join(' | '),
			)
		},
	}

	// =========================
	// ===== ACCESS LOCK =======
	// =========================
	actions['access_lock'] = {
		name: 'System: Access Lock',
		options: [
			{
				type: 'multidropdown',
				id: 'privs',
				label: 'Allowed privileges',
				default: ['1'],
				minSelection: 0,
				choices: [
					{ id: '0', label: 'Lock ALL (everything locked)' },
					{ id: '1', label: 'Project' },
					{ id: '2', label: 'Recall Snapshots' },
					{ id: '4', label: 'Input Types' },
					{ id: '8', label: 'Environment' },
					{ id: '16', label: 'Network Settings' },
					{ id: '32', label: 'Channel Labels' },
					{ id: '64', label: 'Atmospheric Corrections' },
					{ id: '128', label: 'Polarity' },
					{ id: '256', label: 'Input Channel EQ Bypass' },
					{ id: '512', label: 'Output Channel EQ Bypass' },
					{ id: '1024', label: 'Input Gain' },
					{ id: '2048', label: 'Output Gain' },
					{ id: '4096', label: 'Input Parametric EQ' },
					{ id: '8192', label: 'Output Parametric EQ' },
					{ id: '16384', label: 'Input Mute' },
					{ id: '32768', label: 'Output Mute' },
					{ id: '65536', label: 'Input U-Shaping' },
					{ id: '131072', label: 'Output U-Shaping' },
					{ id: '262144', label: 'Output High/Low Pass' },
					{ id: '524288', label: 'Output All Pass' },
					{ id: '1048576', label: 'Input Delays' },
					{ id: '2097152', label: 'Output Delays' },
					{ id: '4194304', label: 'SIM3 Settings' },
					{ id: '8388608', label: 'Summing Matrix' },
					{ id: '16777216', label: 'Delay Matrix' },
					{ id: '33554432', label: 'Link Groups' },
					{ id: '67108864', label: 'Input/Output Voltage Range' },
					{ id: '134217728', label: 'Upload Firmware' },
					{ id: '536870912', label: 'Product Integration' },
					{ id: '1073741824', label: 'Low-Mid Beam Control' },
					{ id: '2147483648', label: 'System Clock' },
					{ id: '9223372036854775807', label: 'Everything (unlock all)' },
				],
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			let total = 0n
			if (Array.isArray(e.options.privs) && e.options.privs.length > 0) {
				if (e.options.privs.includes('0')) {
					total = 0n
				} else {
					for (const v of e.options.privs) {
						try {
							total += BigInt(v)
						} catch (err) {
							self.log?.('warn', `Invalid privilege value: ${v}`)
						}
					}
				}
			}

			try {
				self._cmdSendLine(`/system/access/1/privilege=${total.toString()}`)
				self.accessPrivilege = total
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({ access_privilege: total.toString() })
				}
				if (typeof self.checkFeedbacks === 'function') {
					self.checkFeedbacks('access_priv_has', 'access_priv_equals')
				}
				self.log?.('info', `Access Lock: Set privileges = ${total.toString()}`)
			} catch (err) {
				self.log?.('error', `Access lock failed: ${err?.message || err}`)
			}
		},
	}

	actions['access_priv_toggle'] = {
		name: 'Access: Toggle privilege',
		options: [
			{
				type: 'dropdown',
				id: 'value',
				label: 'Privilege',
				default: '1',
				choices: [
					{ id: '1', label: 'Project' },
					{ id: '2', label: 'Recall Snapshots' },
					{ id: '4', label: 'Input Types' },
					{ id: '8', label: 'Environment' },
					{ id: '16', label: 'Network Settings' },
					{ id: '32', label: 'Channel Labels' },
					{ id: '64', label: 'Atmospheric Corrections' },
					{ id: '128', label: 'Polarity' },
					{ id: '256', label: 'Input Channel EQ Bypass' },
					{ id: '512', label: 'Output Channel EQ Bypass' },
					{ id: '1024', label: 'Input Gain' },
					{ id: '2048', label: 'Output Gain' },
					{ id: '4096', label: 'Input Parametric EQ' },
					{ id: '8192', label: 'Output Parametric EQ' },
					{ id: '16384', label: 'Input Mute' },
					{ id: '32768', label: 'Output Mute' },
					{ id: '65536', label: 'Input U-Shaping' },
					{ id: '131072', label: 'Output U-Shaping' },
					{ id: '262144', label: 'Output High/Low Pass' },
					{ id: '524288', label: 'Output All Pass' },
					{ id: '1048576', label: 'Input Delays' },
					{ id: '2097152', label: 'Output Delays' },
					{ id: '4194304', label: 'SIM3 Settings' },
					{ id: '8388608', label: 'Summing Matrix' },
					{ id: '16777216', label: 'Delay Matrix' },
					{ id: '33554432', label: 'Link Groups' },
					{ id: '67108864', label: 'Input/Output Voltage Range' },
					{ id: '134217728', label: 'Upload Firmware' },
					{ id: '536870912', label: 'Product Integration' },
					{ id: '1073741824', label: 'Low-Mid Beam Control' },
					{ id: '2147483648', label: 'System Clock' },
				],
			},
		],
		callback: (evt) => {
			if (!self) return

			try {
				const bit = BigInt(evt.options.value)
				let now
				if (typeof self.accessPrivilege === 'bigint') {
					now = self.accessPrivilege
				} else if (typeof self.accessPrivilege === 'number') {
					now = BigInt(self.accessPrivilege)
				} else {
					const s = String(nn(self?.getVariableValue?.('access_privilege'), ''))
					try {
						now = BigInt(s)
					} catch {
						now = 0n
					}
				}
				const next = now ^ bit

				if (typeof self._cmdSendLine === 'function') {
					self._cmdSendLine(`/system/access/1/privilege=${next.toString()}`)
				}
				self.accessPrivilege = next
				if (typeof self.setVariableValues === 'function') {
					self.setVariableValues({ access_privilege: next.toString() })
				}
				if (typeof self.checkFeedbacks === 'function') {
					self.checkFeedbacks('access_priv_has', 'access_priv_equals')
				}
			} catch (e) {
				self.log?.('error', `Toggle privilege failed: ${e?.message || e}`)
			}
		},
	}

	actions['front_panel_display_prefs'] = {
		name: 'Front panel: Display preferences',
		description: 'Set Galaxy front panel LCD brightness (0â€“2) and LED color.',
		options: [
			{
				type: 'dropdown',
				id: 'brightness',
				label: 'Brightness',
				default: DISPLAY_NOCHANGE,
				choices: [{ id: DISPLAY_NOCHANGE, label: 'Leave unchanged' }, ...DISPLAY_BRIGHTNESS_CHOICES],
			},
			{
				type: 'dropdown',
				id: 'color',
				label: 'Display color',
				default: DISPLAY_NOCHANGE,
				choices: [{ id: DISPLAY_NOCHANGE, label: 'Leave unchanged' }, ...DISPLAY_COLOR_CHOICES],
			},
		],
		callback: (e) => {
			if (!self) return
			const cmds = []
			const brightness = String(e.options?.brightness ?? DISPLAY_NOCHANGE)
			const color = String(e.options?.color ?? DISPLAY_NOCHANGE)

			if (brightness !== DISPLAY_NOCHANGE) {
				cmds.push(`/device/preferences/brightness=${brightness}`)
			}
			if (color !== DISPLAY_NOCHANGE) {
				cmds.push(`/device/preferences/display_color=${color}`)
			}

			if (cmds.length === 0) {
				self.log?.('warn', 'Front panel display action invoked with no changes selected.')
				return
			}

			if (cmds.length === 1 || typeof self._cmdSendBatch !== 'function') {
				for (const cmd of cmds) {
					if (typeof self._cmdSendLine === 'function') self._cmdSendLine(cmd)
				}
			} else {
				self._cmdSendBatch(cmds)
			}

			if (typeof self._applyDisplayPreference === 'function') {
				if (brightness !== DISPLAY_NOCHANGE) self._applyDisplayPreference('brightness', brightness)
				if (color !== DISPLAY_NOCHANGE) self._applyDisplayPreference('display_color', color)
			}
		},
	}

	actions['front_panel_lockout_control'] = {
		name: 'System: Front panel lockout',
		options: [
			{
				type: 'dropdown',
				id: 'op',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'Lock (ON)' },
					{ id: 'off', label: 'Unlock (OFF)' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const op = e.options.op
			if (op === 'toggle') {
				const cur = self?.miscValues?.front_panel_lockout
				const curBool = typeof cur === 'boolean' ? cur : /^(true|1|on)$/i.test(String(nn(cur, '')).trim())
				self._cmdSendLine(`/system/hardware/front_panel_lockout=${curBool ? 'false' : 'true'}`)
				return
			}
			const state = op === 'on'
			self._cmdSendLine(`/system/hardware/front_panel_lockout=${state ? 'true' : 'false'}`)
		},
	}

	actions['system_identify'] = {
		name: 'System: Identify (front panel blink)',
		options: [
			{
				type: 'dropdown',
				id: 'state',
				label: 'Operation',
				default: 'toggle',
				choices: [
					{ id: 'on', label: 'ON (blink / identify active)' },
					{ id: 'off', label: 'OFF (stop identify)' },
					{ id: 'toggle', label: 'Toggle' },
				],
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const op = e.options.state
			const cur = self?.miscValues?.identify_active
			const curBool = typeof cur === 'boolean' ? cur : /^(true|1|on)$/i.test(String(nn(cur, '')).trim())

			let nextState
			if (op === 'on') nextState = true
			else if (op === 'off') nextState = false
			else nextState = !curBool

			self._cmdSendLine(`/status/identify_active=${nextState ? 'true' : 'false'}`)
			self.miscValues = self.miscValues || {}
			self.miscValues.identify_active = nextState
			if (typeof self.setVariableValues === 'function') {
				self.setVariableValues({ identify_active: nextState ? 'true' : 'false' })
			}
			if (typeof self.checkFeedbacks === 'function') {
				self.checkFeedbacks('identify_active')
			}
			self.log?.('info', `Identify: ${nextState ? 'activated' : 'deactivated'}`)
		},
	}

	actions['system_log_history'] = {
		name: 'System: Fetch log history',
		options: [],
		callback: () => {
			if (!self || typeof self._fetchLogHistory !== 'function') return
			self._fetchLogHistory()
		},
	}

	actions['system_clear_log_history'] = {
		name: 'System: Clear log history',
		options: [],
		callback: () => {
			if (!self || typeof self._cmdSendLine !== 'function') return
			self._cmdSendLine(':clear_log_history')
			self.log?.('info', 'Galaxy log history cleared')
		},
	}

	actions['lcd_text_override'] = {
		name: 'Front panel: LCD text',
		description: 'Set or clear the Galaxy front panel LCD text.',
		options: [
			{
				type: 'dropdown',
				id: 'mode',
				label: 'Operation',
				default: 'set',
				choices: [
					{ id: 'set', label: 'Set custom text' },
					{ id: 'clear', label: 'Clear text' },
				],
			},
			{
				type: 'textinput',
				id: 'line1',
				label: 'Line 1',
				default: '',
				isVisible: (o) => o.mode !== 'clear',
			},
			{
				type: 'textinput',
				id: 'line2',
				label: 'Line 2',
				default: '',
				isVisible: (o) => o.mode !== 'clear',
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendBatch !== 'function') return
			const mode = e.options.mode === 'clear' ? 'clear' : 'set'
			let cmds
			if (mode === 'clear') {
				cmds = ['/device/lcd_text_override/1=""', '/device/lcd_text_override/2=""']
				self._cmdSendBatch(cmds)
				self.log?.('info', 'LCD override cleared')
			} else {
				const l1 = String(e.options.line1 ?? '')
				const l2 = String(e.options.line2 ?? '')
				cmds = [
					`/device/lcd_text_override/1="${l1.replace(/"/g, '\\"')}"`,
					`/device/lcd_text_override/2="${l2.replace(/"/g, '\\"')}"`,
				]
				self._cmdSendBatch(cmds)
				self.log?.('info', `LCD override set: [${l1}] | [${l2}]`)
			}
		},
	}

	actions['system_reboot'] = {
		name: 'System: Reboot Galaxy',
		description: 'Reboot the Galaxy into a selected mode. Use with care!',
		options: [
			{
				type: 'dropdown',
				id: 'mode',
				label: 'Reboot mode',
				default: 'running',
				choices: [
					{ id: 'running', label: 'Running (normal)' },
					{ id: 'recovery', label: 'Recovery' },
					{ id: 'defaults', label: 'Factory defaults' },
					{ id: 'diagnostic', label: 'Diagnostic' },
					{ id: 'core', label: 'Core' },
				],
			},
			{
				type: 'checkbox',
				id: 'confirm',
				label: 'Yes, reboot the Galaxy now',
				default: false,
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return
			if (!e.options.confirm) {
				self.log?.('warn', 'Reboot skipped: confirmation checkbox not checked')
				return
			}
			const mode = String(e.options.mode || '').toLowerCase()
			if (!['running', 'recovery', 'defaults', 'diagnostic', 'core'].includes(mode)) {
				self.log?.('warn', `Reboot skipped: invalid mode "${e.options.mode}"`)
				return
			}
			self._cmdSendLine(`:reboot ${mode}`)
			self.log?.('info', `Galaxy reboot requested (mode=${mode})`)
		},
	}

	actions['system_add_log_message'] = {
		name: 'System: Post log message',
		description: 'Send a custom message into the Galaxy system log.',
		options: [
			{
				type: 'textinput',
				id: 'message',
				label: 'Log message',
				default: 'Companion connected',
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return
			const msg = String(e?.message || e?.options?.message || '').trim()
			if (!msg) {
				self.log?.('warn', 'Add log message skipped: message is empty')
				return
			}
			const safe = msg.replace(/"/g, '\\"')
			self._cmdSendLine(`:add_log_message "${safe}"`)
			self.log?.('info', `Galaxy log message queued: ${msg}`)
		},
	}

	actions['system_set_clock_source'] = {
		name: 'System: Set clock source',
		description: 'Change the Galaxy system clock source (optional input for AES/AVB/CRF).',
		options: [
			{
				type: 'dropdown',
				id: 'source',
				label: 'Clock source',
				default: 'internal',
				choices: [
					{ id: 'internal', label: 'Internal' },
					{ id: 'aes', label: 'AES (digital)' },
					{ id: 'avb', label: 'AVB' },
					{ id: 'crf', label: 'CRF' },
					{ id: 'bnc', label: 'BNC (Word Clock)' },
				],
			},
			{
				type: 'dropdown',
				id: 'input',
				label: 'Input number',
				default: '1',
				choices: [
					{ id: '1', label: 'Input A (1)' },
					{ id: '2', label: 'Input B (2)' },
					{ id: '3', label: 'Input C (3)' },
				],
				isVisible: (o) => o.source === 'aes' || o.source === 'avb' || o.source === 'crf',
			},
			{
				type: 'static-text',
				id: 'bncInfo',
				label: 'BNC/Internal note',
				value: 'BNC and Internal sources ignore the input number.',
				isVisible: (o) => o.source === 'bnc' || o.source === 'internal',
			},
		],
		callback: (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return
			const src = String(e.options.source || '').toLowerCase()
			if (!['aes', 'avb', 'crf', 'bnc', 'internal'].includes(src)) {
				self.log?.('warn', `Clock source change skipped: invalid source "${e.options.source}"`)
				return
			}

			let inputNum = ''
			if (src === 'aes' || src === 'avb' || src === 'crf') {
				const chosen = Number(e.options.input)
				if (!Number.isInteger(chosen) || chosen < 1) {
					self.log?.('warn', `Clock source change skipped: invalid input number "${e.options.input}"`)
					return
				}
				inputNum = String(chosen)
			} else {
				inputNum = ''
			}

			const cmd = inputNum ? `:set_clock_source ${src} ${inputNum}` : `:set_clock_source ${src}`
			self._cmdSendLine(cmd)
			self.log?.('info', `Clock source command sent: ${cmd}`)
		},
	}

	// =========================
	// ===== SNAPSHOTS =========
	// =========================

	const activeSnapshotInfo = buildActiveSnapshotLabel(self)
	const allSnapshotChoices = buildSnapshotChoices(self)
	const snapshotDropdownChoices = allSnapshotChoices.length
		? [...allSnapshotChoices]
		: [{ id: '', label: 'No snapshots available' }]
	const snapshotBootChoices = [...snapshotDropdownChoices, { id: '-1', label: 'Clear boot snapshot (disable boot)' }]

	// Combined Snapshot Action
	actions['snapshot_combined'] = {
		name: 'Snapshot: Combined Operations',
		description: 'Perform various snapshot operations from a single action.',
		options: [
			{
				type: 'static-text',
				id: 'activeInfo',
				label: 'Current active snapshot',
				value: activeSnapshotInfo,
			},
			{
				type: 'dropdown',
				id: 'operation',
				label: 'Operation',
				default: 'recall',
				choices: [
					{ id: 'recall', label: 'Recall' },
					{ id: 'update', label: 'Update (rewrite)' },
					{ id: 'create', label: 'Create (new)' },
					{ id: 'duplicate', label: 'Duplicate' },
					{ id: 'rename', label: 'Rename (set name & comment)' },
					{ id: 'set_boot', label: 'Set boot snapshot' },
					{ id: 'delete', label: 'Delete' },
					{ id: 'lock', label: 'Lock' },
					{ id: 'unlock', label: 'Unlock' },
				],
			},
			{
				type: 'dropdown',
				id: 'snapshot_id',
				label: 'Snapshot',
				default: allSnapshotChoices[0]?.id ?? '',
				choices: snapshotDropdownChoices,
				isVisible: (options) => {
					const op = options.operation
					return ['recall', 'duplicate', 'delete', 'lock', 'unlock'].includes(op)
				},
			},
			{
				type: 'dropdown',
				id: 'snapshot_id_boot',
				label: 'Snapshot',
				default: '-1',
				choices: snapshotBootChoices,
				isVisible: (options) => options.operation === 'set_boot',
			},
			{
				type: 'dropdown',
				id: 'snapshot_id_update',
				label: 'Snapshot',
				default: 'active',
				choices: [
					{ id: 'active', label: activeSnapshotInfo },
					...allSnapshotChoices.filter((choice) => {
						const id = Number(choice.id)
						if (!Number.isFinite(id) || id < 1) return false
						const locked = String(self?.snapshotValues?.[`snapshot_${id}_locked`] ?? '').trim()
						return !/^(true|1|on)$/i.test(locked)
					}),
				],
				isVisible: (options) => options.operation === 'update',
			},
			{
				type: 'dropdown',
				id: 'snapshot_id_rename',
				label: 'Snapshot',
				default:
					allSnapshotChoices.filter((choice) => {
						const id = Number(choice.id)
						if (!Number.isFinite(id) || id < 1) return false
						const locked = String(self?.snapshotValues?.[`snapshot_${id}_locked`] ?? '').trim()
						return !/^(true|1|on)$/i.test(locked)
					})[0]?.id ?? '',
				choices: allSnapshotChoices.filter((choice) => {
					const id = Number(choice.id)
					if (!Number.isFinite(id) || id < 1) return false
					const locked = String(self?.snapshotValues?.[`snapshot_${id}_locked`] ?? '').trim()
					return !/^(true|1|on)$/i.test(locked)
				}),
				isVisible: (options) => options.operation === 'rename',
			},
			{
				type: 'textinput',
				id: 'snapshot_name',
				label: 'Snapshot name',
				default: '',
				useVariables: true,
				isVisible: (options) => ['create', 'rename'].includes(options.operation),
			},
			{
				type: 'textinput',
				id: 'snapshot_comment',
				label: 'Snapshot comment',
				default: '',
				useVariables: true,
				isVisible: (options) => ['create', 'rename'].includes(options.operation),
			},
			{
				type: 'checkbox',
				id: 'confirm_delete',
				label: 'YES â€” really delete this snapshot',
				default: false,
				isVisible: (options) => options.operation === 'delete',
			},
			{
				type: 'checkbox',
				id: 'exclude_input_channel_types',
				label: 'Exclude Input Channel Types',
				default: false,
				isVisible: (options) => options.operation === 'recall',
			},
			{
				type: 'checkbox',
				id: 'exclude_voltage_ranges',
				label: 'Exclude Input and Output Voltage Ranges',
				default: false,
				isVisible: (options) => options.operation === 'recall',
			},
			{
				type: 'checkbox',
				id: 'exclude_mute',
				label: 'Exclude Input and Output Mute',
				default: false,
				isVisible: (options) => options.operation === 'recall',
			},
			{
				type: 'checkbox',
				id: 'exclude_update_active',
				label: 'Exclude Update active snapshot before recall',
				default: false,
				isVisible: (options) => options.operation === 'recall',
			},
			{
				type: 'checkbox',
				id: 'exclude_sim3_bus',
				label: 'Exclude SIM3 Bus Address',
				default: false,
				isVisible: (options) => options.operation === 'recall',
			},
			{
				type: 'checkbox',
				id: 'exclude_sim3_probe',
				label: 'Exclude SIM3 Probe Point',
				default: false,
				isVisible: (options) => options.operation === 'recall',
			},
			{
				type: 'checkbox',
				id: 'exclude_clock_sync',
				label: 'Exclude Clock Sync Mode',
				default: false,
				isVisible: (options) => options.operation === 'recall',
			},
			{
				type: 'checkbox',
				id: 'exclude_avb',
				label: 'Exclude AVB Configuration',
				default: false,
				isVisible: (options) => options.operation === 'recall',
			},
		],
		callback: async (e) => {
			if (!self || typeof self._cmdSendLine !== 'function') return

			const operation = e.options.operation

			// RECALL
			if (operation === 'recall') {
				const id = Number(e.options.snapshot_id)
				if (!Number.isFinite(id) || id < 0 || id > SNAPSHOT_MAX) {
					self.log?.('warn', `Snapshot recall skipped: invalid id "${e.options.snapshot_id}"`)
					return
				}

				// Calculate exclusion code by summing selected checkboxes
				let exclusionCode = 1 // Default: nothing excluded (code 1)
				if (e.options.exclude_input_channel_types) exclusionCode += 2
				if (e.options.exclude_voltage_ranges) exclusionCode += 4
				if (e.options.exclude_mute) exclusionCode += 8
				if (e.options.exclude_update_active) exclusionCode += 16
				if (e.options.exclude_sim3_bus) exclusionCode += 32
				if (e.options.exclude_sim3_probe) exclusionCode += 64
				if (e.options.exclude_clock_sync) exclusionCode += 128
				if (e.options.exclude_avb) exclusionCode += 256

				// If any exclusion is selected, we don't add 1 (we just sum the selected codes)
				if (exclusionCode > 1) {
					exclusionCode -= 1 // Remove the default 1 since we have actual exclusions
				}

				self._cmdSendLine(`:recall_snapshot ${id} ${exclusionCode}`)
				self.log?.('info', `Snapshot: recalled id=${id} with exclusion code=${exclusionCode}`)
			}

			// UPDATE
			else if (operation === 'update') {
				const opt = String(e.options.snapshot_id_update ?? '').trim()
				let id = null
				let fromActive = false

				if (opt === 'active') {
					fromActive = true
					let raw = self?.snapshotValues?.snapshot_active_id
					if (raw == null && typeof self?.getVariableValue === 'function') {
						raw = self.getVariableValue('snapshot_active_id')
					}
					id = Number(raw)
				} else {
					id = Number(opt)
				}

				if (!Number.isFinite(id) || id < 1 || id > SNAPSHOT_MAX) {
					self.log?.('warn', `Snapshot update skipped: invalid id "${opt}"`)
					return
				}

				const locked = String(self?.snapshotValues?.[`snapshot_${id}_locked`] ?? '').trim()
				if (/^(true|1|on)$/i.test(locked)) {
					self.log?.('warn', `Snapshot update skipped: snapshot ${id} is locked`)
					return
				}

				self._cmdSendLine(`:update_snapshot ${id}`)
				self.log?.('info', `Snapshot: requested update of snapshot id=${id}${fromActive ? ' (active)' : ''}`)

				setTimeout(() => {
					try {
						if (typeof self.requestSnapshots === 'function') {
							self.requestSnapshots()
						}
					} catch (err) {
						self.log?.('debug', `Snapshot update refresh failed: ${err?.message || err}`)
					}
				}, 500)
			}

			// CREATE
			else if (operation === 'create') {
				const name = await self.parseVariablesInString(String(e.options.snapshot_name ?? ''))
				const comment = await self.parseVariablesInString(String(e.options.snapshot_comment ?? ''))

				self._cmdSendLine(`:create_snapshot ${quoteSnapshotArg(name)} ${quoteSnapshotArg(comment)}`)
				self.log?.('info', `Snapshot: create requested (name="${name}" comment="${comment}")`)

				setTimeout(() => {
					try {
						if (typeof self.requestSnapshots === 'function') {
							self.requestSnapshots()
						}
					} catch (err) {
						self.log?.('debug', `Snapshot create refresh failed: ${err?.message || err}`)
					}
				}, 500)
			}

			// DUPLICATE
			else if (operation === 'duplicate') {
				const id = Number(e.options.snapshot_id)
				if (!Number.isFinite(id) || id < 0 || id > SNAPSHOT_MAX) {
					self.log?.('warn', `Snapshot duplicate skipped: invalid id "${e.options.snapshot_id}"`)
					return
				}

				self._cmdSendLine(`:duplicate_snapshot ${id}`)
				self.log?.('info', `Snapshot: duplicate requested for id=${id}`)

				setTimeout(() => {
					try {
						if (typeof self.requestSnapshots === 'function') {
							self.requestSnapshots()
						}
					} catch (err) {
						self.log?.('debug', `Snapshot duplicate refresh failed: ${err?.message || err}`)
					}
				}, 500)
			}

			// SET BOOT SNAPSHOT
			else if (operation === 'set_boot') {
				const id = Number(e.options.snapshot_id_boot)
				if (!Number.isFinite(id) || id < -1 || id > SNAPSHOT_MAX) {
					self.log?.('warn', `Snapshot boot skipped: invalid id "${e.options.snapshot_id_boot}"`)
					return
				}

				self._cmdSendLine(`:set_boot_snapshot ${id}`)
				if (id === -1) {
					self.log?.('info', 'Snapshot: cleared boot snapshot (no snapshot at boot)')
				} else {
					self.log?.('info', `Snapshot: set boot snapshot id=${id}`)
				}
			}

			// RENAME (Set Name & Comment)
			else if (operation === 'rename') {
				const id = Number(e.options.snapshot_id_rename)
				if (!id) {
					self.log?.('warn', 'Snapshot rename skipped: no snapshot selected')
					return
				}
				const locked = String(self?.snapshotValues?.[`snapshot_${id}_locked`] ?? '').trim()
				if (/^(true|1|on)$/i.test(locked)) {
					self.log?.('warn', `Snapshot rename skipped: snapshot ${id} is locked`)
					return
				}
				if (!Number.isFinite(id) || id < 1 || id > SNAPSHOT_MAX) {
					self.log?.('warn', `Snapshot rename skipped: invalid id "${e.options.snapshot_id_rename}"`)
					return
				}

				const name = await self.parseVariablesInString(String(e.options.snapshot_name ?? ''))
				const comment = await self.parseVariablesInString(String(e.options.snapshot_comment ?? ''))

				if (name || comment) {
					self._cmdSendLine(
						`:set_snapshot_name ${id} ${quoteSnapshotArg(name)}`,
						`:set_snapshot_comment ${id} ${quoteSnapshotArg(comment)}`,
					)
				} else {
					self._cmdSendLine(`:set_snapshot_name ${id} ${quoteSnapshotArg(name)}`)
				}

				self.log?.('info', `Snapshot: set name/comment for id=${id} (name="${name}" comment="${comment}")`)

				if (typeof self._applySnapshotValue === 'function') {
					self._applySnapshotValue(`snapshot_${id}_name`, name)
					self._applySnapshotValue(`snapshot_${id}_comment`, comment)
					let activeRaw = self?.snapshotValues?.snapshot_active_id
					if (activeRaw == null && typeof self?.getVariableValue === 'function') {
						activeRaw = self.getVariableValue('snapshot_active_id')
					}
					const activeId = Number(activeRaw)
					if (Number.isFinite(activeId) && activeId === id) {
						self._applySnapshotValue('snapshot_active_name', name)
						self._applySnapshotValue('snapshot_active_comment', comment)
					}
				}

				setTimeout(() => {
					try {
						if (typeof self.requestSnapshots === 'function') {
							self.requestSnapshots()
						}
					} catch (err) {
						self.log?.('debug', `Snapshot rename refresh failed: ${err?.message || err}`)
					}
				}, 500)
			}

			// DELETE
			else if (operation === 'delete') {
				if (!e.options.confirm_delete) {
					self.log?.('warn', `Snapshot delete aborted â€” confirm box was not checked`)
					return
				}

				const id = Number(e.options.snapshot_id)
				if (!Number.isFinite(id) || id < 1 || id > SNAPSHOT_MAX) {
					self.log?.('warn', `Snapshot delete skipped: invalid id "${e.options.snapshot_id}"`)
					return
				}

				self._cmdSendLine(`:delete_snapshot ${id}`)
				self.log?.('info', `Snapshot: deleted id=${id}`)

				setTimeout(() => {
					try {
						if (typeof self.requestSnapshots === 'function') {
							self.requestSnapshots()
						}
					} catch (err) {
						self.log?.('debug', `Snapshot refresh failed: ${err?.message || err}`)
					}
				}, 500)
			}

			// LOCK
			else if (operation === 'lock') {
				const id = Number(e.options.snapshot_id)
				if (!Number.isFinite(id) || id < 1 || id > SNAPSHOT_MAX) {
					self.log?.('warn', `Snapshot lock skipped: invalid id "${e.options.snapshot_id}"`)
					return
				}

				self._cmdSendLine(`:lock_snapshot ${id}`)
				self.log?.('info', `Snapshot: lock id=${id}`)

				if (typeof self._applySnapshotValue === 'function') {
					self._applySnapshotValue(`snapshot_${id}_locked`, 'true')
					let raw = self?.snapshotValues?.snapshot_active_id
					if (raw == null && typeof self?.getVariableValue === 'function')
						raw = self.getVariableValue('snapshot_active_id')
					const activeId = Number(raw)
					if (Number.isFinite(activeId) && activeId === id) {
						self._applySnapshotValue('snapshot_active_locked', 'true')
					}
				}

				setTimeout(() => {
					try {
						if (typeof self.requestSnapshots === 'function') {
							self.requestSnapshots()
						}
					} catch (err) {
						self.log?.('debug', `Snapshot lock refresh failed: ${err?.message || err}`)
					}
				}, 500)
			}

			// UNLOCK
			else if (operation === 'unlock') {
				const id = Number(e.options.snapshot_id)
				if (!Number.isFinite(id) || id < 1 || id > SNAPSHOT_MAX) {
					self.log?.('warn', `Snapshot unlock skipped: invalid id "${e.options.snapshot_id}"`)
					return
				}

				self._cmdSendLine(`:unlock_snapshot ${id}`)
				self.log?.('info', `Snapshot: unlock id=${id}`)

				if (typeof self._applySnapshotValue === 'function') {
					self._applySnapshotValue(`snapshot_${id}_locked`, 'false')
					let raw = self?.snapshotValues?.snapshot_active_id
					if (raw == null && typeof self?.getVariableValue === 'function')
						raw = self.getVariableValue('snapshot_active_id')
					const activeId = Number(raw)
					if (Number.isFinite(activeId) && activeId === id) {
						self._applySnapshotValue('snapshot_active_locked', 'false')
					}
				}

				setTimeout(() => {
					try {
						if (typeof self.requestSnapshots === 'function') {
							self.requestSnapshots()
						}
					} catch (err) {
						self.log?.('debug', `Snapshot unlock refresh failed: ${err?.message || err}`)
					}
				}, 500)
			}
		},
	}

	// ============================================================
	// === Sub Design Assist: End-Fire (Multi-depth T0..Tn) =======
	// ============================================================
	function subassistPreview(self) {
		const d = self?._subassist || null
		if (!d || typeof d.spacing_m !== 'number') return '-- Run once to update preview --'
		const ft = d.spacing_m * 3.28084
		return `${ft.toFixed(2)} ft  (${d.spacing_m.toFixed(3)} m)`
	}

	function endfirePreview(self) {
		const d = self?._subassist || null
		if (!d || typeof d.c !== 'number' || typeof d.T !== 'number') return '-- Run once to update preview --'
		const c_mps = d.c
		const c_fps = c_mps * 3.28084
		const T_C = d.T
		const T_F = (T_C * 9) / 5 + 32
		return `c â‰ˆ ${c_mps.toFixed(1)} m/s (${c_fps.toFixed(1)} ft/s) at ${T_C.toFixed(1)} Â°C (${T_F.toFixed(1)} Â°F)`
	}

	// ============================================================
	// === Sub Array: Electronic Arc (Virtual Arc Delays) =========
	// ============================================================

	function arcPreview(self) {
		const d = self?._arcassist
		if (!d || typeof d.c !== 'number') return '-- Run once to update preview --'
		const c_mps = d.c
		const c_fps = c_mps * 3.28084
		const T_C = d.T
		const T_F = (T_C * 9) / 5 + 32
		return `c â‰ˆ ${c_mps.toFixed(1)} m/s (${c_fps.toFixed(1)} ft/s) at ${T_C.toFixed(1)} Â°C (${T_F.toFixed(1)} Â°F)`
	}

	// =========================
	// ===== SUB DESIGN ASSIST ======
	// =========================
	actions['subassist_combined'] = {
		name: 'Sub Design Assist',
		options: [
			{
				type: 'dropdown',
				id: 'mode',
				label: 'Mode',
				default: 'endfire',
				choices: [
					{ id: 'endfire', label: 'End-Fire' },
					{ id: 'array', label: 'Array' },
					{ id: 'array_endfire', label: 'Array End-Fire' },
					{ id: 'gradient', label: 'Gradient' },
				],
			},

			// ===== END-FIRE OPTIONS =====
			{
				type: 'dropdown',
				id: 'endfire_speaker',
				label: 'Loudspeaker (optional)',
				default: '',
				choices: subwooferSpeakerChoices,
				isVisible: (o) => o.mode === 'endfire',
			},
			...endfireStartingPointOptionDefs,
			{
				type: 'checkbox',
				id: 'reset_endfire',
				label: 'Reset channels to factory defaults before applying',
				default: false,
				isVisible: (o) => o.mode === 'endfire',
			},
			{
				type: 'static-text',
				id: 'preview',
				label: 'Recommended spacing',
				value: subassistPreview(self),
				isVisible: (o) => o.mode === 'endfire',
			},
			{
				type: 'static-text',
				id: 'speed_preview',
				label: 'Speed of sound',
				value: endfirePreview(self),
				isVisible: (o) => o.mode === 'endfire',
			},
			{
				type: 'number',
				id: 'freq',
				label: 'Target frequency (Hz)',
				default: 80,
				min: 10,
				max: 200,
				step: 1,
				isVisible: (o) => o.mode === 'endfire',
			},
			{
				type: 'number',
				id: 'temp_endfire',
				label: 'Air temperature',
				default: 20,
				min: -40,
				max: 140,
				step: 0.1,
				isVisible: (o) => o.mode === 'endfire',
			},
			{
				type: 'dropdown',
				id: 'tempUnit_endfire',
				label: 'Temperature unit',
				default: 'C',
				choices: [
					{ id: 'C', label: 'Â°C' },
					{ id: 'F', label: 'Â°F' },
				],
				isVisible: (o) => o.mode === 'endfire',
			},
			{
				type: 'dropdown',
				id: 'depth',
				label: 'Depth (number of taps)',
				default: '2',
				choices: [
					{ id: '2', label: '2 (T0..T1)' },
					{ id: '3', label: '3 (T0..T2)' },
					{ id: '4', label: '4 (T0..T3)' },
					{ id: '5', label: '5 (T0..T4)' },
					{ id: '6', label: '6 (T0..T5)' },
					{ id: '7', label: '7 (T0..T6)' },
					{ id: '8', label: '8 (T0..T7)' },
				],
				isVisible: (o) => o.mode === 'endfire',
			},
			{
				type: 'multidropdown',
				id: 't0',
				label: 'T0 outputs (0 ms)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'endfire' && Number(o.depth) >= 1,
			},
			{
				type: 'multidropdown',
				id: 't1',
				label: 'T1 outputs (1x delay)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'endfire' && Number(o.depth) >= 2,
			},
			{
				type: 'multidropdown',
				id: 't2',
				label: 'T2 outputs (2x delay)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'endfire' && Number(o.depth) >= 3,
			},
			{
				type: 'multidropdown',
				id: 't3',
				label: 'T3 outputs (3x delay)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'endfire' && Number(o.depth) >= 4,
			},
			{
				type: 'multidropdown',
				id: 't4',
				label: 'T4 outputs (4x delay)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'endfire' && Number(o.depth) >= 5,
			},
			{
				type: 'multidropdown',
				id: 't5',
				label: 'T5 outputs (5x delay)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'endfire' && Number(o.depth) >= 6,
			},
			{
				type: 'multidropdown',
				id: 't6',
				label: 'T6 outputs (6x delay)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'endfire' && Number(o.depth) >= 7,
			},
			{
				type: 'multidropdown',
				id: 't7',
				label: 'T7 outputs (7x delay)',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'endfire' && Number(o.depth) >= 8,
			},
			{
				type: 'dropdown',
				id: 'endfire_link_group',
				label: 'Assign to Output Link Group',
				default: '0',
				choices: [
					{ id: '0', label: 'None (Unassigned)' },
					{ id: '1', label: 'Link Group 1' },
					{ id: '2', label: 'Link Group 2' },
					{ id: '3', label: 'Link Group 3' },
					{ id: '4', label: 'Link Group 4' },
					{ id: '5', label: 'Link Group 5' },
					{ id: '6', label: 'Link Group 6' },
					{ id: '7', label: 'Link Group 7' },
					{ id: '8', label: 'Link Group 8' },
				],
				isVisible: (o) => o.mode === 'endfire',
			},
			{
				type: 'checkbox',
				id: 'endfire_link_group_enable',
				label: 'Enable the selected Output Link Group',
				default: true,
				isVisible: (o) => o.mode === 'endfire' && o.endfire_link_group !== '0',
			},

			// ===== ARRAY OPTIONS =====
			{
				type: 'dropdown',
				id: 'array_speaker',
				label: 'Loudspeaker (optional)',
				default: '',
				choices: subwooferSpeakerChoices,
				isVisible: (o) => o.mode === 'array',
			},
			...arrayStartingPointOptionDefs,
			{
				type: 'checkbox',
				id: 'reset_array',
				label: 'Reset channels to factory defaults before applying',
				default: false,
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'number',
				id: 'numSubs',
				label: 'Number of subs',
				default: 6,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'dropdown',
				id: 'startCh',
				label: 'Starting output channel',
				default: '',
				choices: outputChoicesFriendly,
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'dropdown',
				id: 'units',
				label: 'Units',
				default: 'm',
				choices: [
					{ id: 'm', label: 'Meters' },
					{ id: 'ft', label: 'Feet' },
				],
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'number',
				id: 'spacing',
				label: 'Sub spacing',
				default: 1.0,
				step: 0.01,
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'number',
				id: 'radius',
				label: 'Arc angle (degrees)',
				default: 60,
				min: 0,
				max: 120,
				step: 1,
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'number',
				id: 'temp_array',
				label: 'Air temperature',
				default: 20.0,
				step: 0.1,
				min: -40,
				max: 140,
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'dropdown',
				id: 'tempUnit_array',
				label: 'Temperature unit',
				default: 'C',
				choices: [
					{ id: 'C', label: 'Â°C' },
					{ id: 'F', label: 'Â°F' },
				],
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'static-text',
				id: 'arc_preview',
				label: 'Speed of sound',
				value: arcPreview(self),
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'dropdown',
				id: 'array_link_group',
				label: 'Assign to Output Link Group',
				default: '0',
				choices: [
					{ id: '0', label: 'None (Unassigned)' },
					{ id: '1', label: 'Link Group 1' },
					{ id: '2', label: 'Link Group 2' },
					{ id: '3', label: 'Link Group 3' },
					{ id: '4', label: 'Link Group 4' },
					{ id: '5', label: 'Link Group 5' },
					{ id: '6', label: 'Link Group 6' },
					{ id: '7', label: 'Link Group 7' },
					{ id: '8', label: 'Link Group 8' },
				],
				isVisible: (o) => o.mode === 'array',
			},
			{
				type: 'checkbox',
				id: 'array_link_group_enable',
				label: 'Enable the selected Output Link Group',
				default: true,
				isVisible: (o) => o.mode === 'array' && o.array_link_group !== '0',
			},

			// ===== ARRAY END-FIRE OPTIONS =====
			{
				type: 'dropdown',
				id: 'arrayendfire_speaker',
				label: 'Loudspeaker (optional)',
				default: '',
				choices: subwooferSpeakerChoices,
				isVisible: (o) => o.mode === 'array_endfire',
			},
			...arrayendfireStartingPointOptionDefs,
			{
				type: 'checkbox',
				id: 'reset_arrayendfire',
				label: 'Reset channels to factory defaults before applying',
				default: false,
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'number',
				id: 'freq_arrayendfire',
				label: 'End-Fire frequency (Hz)',
				default: 80,
				min: 20,
				max: 200,
				step: 0.1,
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'number',
				id: 'depth_arrayendfire',
				label: 'End-Fire depth (rows: 2-8)',
				default: 2,
				min: 2,
				max: 8,
				step: 1,
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'number',
				id: 'numSubs_arrayendfire',
				label: 'Number of subs per row',
				default: 6,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'number',
				id: 'startCh_front_arrayendfire',
				label: 'First output (front row)',
				default: 1,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'number',
				id: 'startCh_second_arrayendfire',
				label: 'First output (second row)',
				default: 7,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array_endfire' && Number(o.depth_arrayendfire) >= 2,
			},
			{
				type: 'number',
				id: 'startCh_third_arrayendfire',
				label: 'First output (third row)',
				default: 13,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array_endfire' && Number(o.depth_arrayendfire) >= 3,
			},
			{
				type: 'number',
				id: 'startCh_fourth_arrayendfire',
				label: 'First output (fourth row)',
				default: 19,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array_endfire' && Number(o.depth_arrayendfire) >= 4,
			},
			{
				type: 'number',
				id: 'startCh_fifth_arrayendfire',
				label: 'First output (fifth row)',
				default: 25,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array_endfire' && Number(o.depth_arrayendfire) >= 5,
			},
			{
				type: 'number',
				id: 'startCh_sixth_arrayendfire',
				label: 'First output (sixth row)',
				default: 31,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array_endfire' && Number(o.depth_arrayendfire) >= 6,
			},
			{
				type: 'number',
				id: 'startCh_seventh_arrayendfire',
				label: 'First output (seventh row)',
				default: 37,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array_endfire' && Number(o.depth_arrayendfire) >= 7,
			},
			{
				type: 'number',
				id: 'startCh_eighth_arrayendfire',
				label: 'First output (eighth row)',
				default: 43,
				min: 1,
				max: NUM_OUTPUTS,
				isVisible: (o) => o.mode === 'array_endfire' && Number(o.depth_arrayendfire) >= 8,
			},
			{
				type: 'dropdown',
				id: 'units_arrayendfire',
				label: 'Units',
				default: 'm',
				choices: [
					{ id: 'm', label: 'Meters' },
					{ id: 'ft', label: 'Feet' },
				],
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'number',
				id: 'spacing_arrayendfire',
				label: 'Sub spacing',
				default: 1.0,
				step: 0.01,
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'number',
				id: 'radius_arrayendfire',
				label: 'Arc angle (degrees)',
				default: 60,
				min: 0,
				max: 120,
				step: 1,
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'number',
				id: 'temp_arrayendfire',
				label: 'Air temperature',
				default: 20.0,
				step: 0.1,
				min: -40,
				max: 140,
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'dropdown',
				id: 'tempUnit_arrayendfire',
				label: 'Temperature unit',
				default: 'C',
				choices: [
					{ id: 'C', label: 'Â°C' },
					{ id: 'F', label: 'Â°F' },
				],
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'dropdown',
				id: 'arrayendfire_link_group',
				label: 'Assign to Output Link Group',
				default: '0',
				choices: [
					{ id: '0', label: 'None (Unassigned)' },
					{ id: '1', label: 'Link Group 1' },
					{ id: '2', label: 'Link Group 2' },
					{ id: '3', label: 'Link Group 3' },
					{ id: '4', label: 'Link Group 4' },
					{ id: '5', label: 'Link Group 5' },
					{ id: '6', label: 'Link Group 6' },
					{ id: '7', label: 'Link Group 7' },
					{ id: '8', label: 'Link Group 8' },
				],
				isVisible: (o) => o.mode === 'array_endfire',
			},
			{
				type: 'checkbox',
				id: 'arrayendfire_link_group_enable',
				label: 'Enable the selected Output Link Group',
				default: true,
				isVisible: (o) => o.mode === 'array_endfire' && o.arrayendfire_link_group !== '0',
			},

			// ===== GRADIENT OPTIONS =====
			{
				type: 'dropdown',
				id: 'gradient_speaker',
				label: 'Loudspeaker',
				default: '',
				choices: subwooferSpeakerChoices,
				isVisible: (o) => o.mode === 'gradient',
			},
			...gradientStartingPointOptionDefs_Front,
			{
				type: 'multidropdown',
				id: 'gradient_outputs_front',
				label: 'Output Front',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'gradient',
			},
			...gradientStartingPointOptionDefs_Reversed,
			{
				type: 'multidropdown',
				id: 'gradient_outputs_reversed',
				label: 'Output Reversed',
				default: [],
				choices: outputChoicesFriendly,
				minSelection: 0,
				isVisible: (o) => o.mode === 'gradient',
			},
			{
				type: 'checkbox',
				id: 'reset_gradient',
				label: 'Reset channels to factory defaults before applying',
				default: false,
				isVisible: (o) => o.mode === 'gradient',
			},
			{
				type: 'dropdown',
				id: 'gradient_link_group',
				label: 'Assign to Output Link Group',
				default: '0',
				choices: [
					{ id: '0', label: 'None (Unassigned)' },
					{ id: '1', label: 'Link Group 1' },
					{ id: '2', label: 'Link Group 2' },
					{ id: '3', label: 'Link Group 3' },
					{ id: '4', label: 'Link Group 4' },
					{ id: '5', label: 'Link Group 5' },
					{ id: '6', label: 'Link Group 6' },
					{ id: '7', label: 'Link Group 7' },
					{ id: '8', label: 'Link Group 8' },
				],
				isVisible: (o) => o.mode === 'gradient',
			},
			{
				type: 'checkbox',
				id: 'gradient_link_group_enable',
				label: 'Enable the selected Output Link Group',
				default: true,
				isVisible: (o) => o.mode === 'gradient' && o.gradient_link_group !== '0',
			},
		],
		callback: async (e) => {
			const mode = e.options.mode

			if (mode === 'endfire') {
				// Execute End-Fire logic
				const f = Math.max(1e-6, Number(e.options.freq) || 80)
				const unitIn = e.options.tempUnit_endfire === 'F' ? 'F' : 'C'
				let T = Number.isFinite(Number(e.options.temp_endfire)) ? Number(e.options.temp_endfire) : 20
				if (unitIn === 'F') T = ((T - 32) * 5) / 9
				const c = speedOfSound_mps(T)

				const depth = Math.min(8, Math.max(2, Number(e.options.depth) || 2))

				const spacing_m = c / (4 * f)
				self._subassist = { spacing_m, T, c }
				self.setVariableValues?.({
					subassist_spacing_ft: (spacing_m * 3.28084).toFixed(2),
					subassist_spacing_m: spacing_m.toFixed(3),
				})

				const roundTo01 = (val) => Math.round(val / 0.01) * 0.01
				const perTapMs = roundTo01(1000 / (4 * f))
				const perTapSamples = Math.round(perTapMs * 96)

				const taps = []
				for (let t = 0; t < depth; t++) {
					const key = `t${t}`
					const arr = Array.isArray(e.options[key])
						? e.options[key].map(Number)
						: e.options[key]
							? [Number(e.options[key])]
							: []
					taps.push(arr.filter((ch) => Number.isFinite(ch) && ch >= 1 && ch <= NUM_OUTPUTS))
				}

				// Get product integration settings if specified
				const speakerKey = String(e.options?.endfire_speaker || '')
				let typeId = null
				let startingPointCommands = null
				let startingPointTitle = ''

				if (speakerKey && speakerKey !== 'OFF' && speakerKey !== '') {
					const speakerEntry = productIntegrationSpeakers.get(speakerKey)
					if (speakerEntry?.phases?.length > 0) {
						const fallbackPhase = speakerEntry.phases[0]
						typeId = fallbackPhase?.typeId ?? null
					}

					const startingPointOptionId = endfireSpeakerStartingPointOption.get(speakerKey)
					if (startingPointOptionId) {
						const startingPointId = String(e.options?.[startingPointOptionId] || '').trim()
						if (startingPointId) {
							const entries = productIntegrationStartingPoints.get(speakerKey) || []
							const entry = entries.find((sp) => sp.id === startingPointId)
							if (entry && Array.isArray(entry.controlPoints) && entry.controlPoints.length > 0) {
								startingPointCommands = entry.controlPoints
								startingPointTitle = entry.title || ''
							}
						}
					}
				}

				// Check if factory reset is enabled
				const shouldReset = e.options.reset_endfire === true

				const lines = []
				for (let t = 0; t < taps.length; t++) {
					const targetSamples = t * perTapSamples
					const targetMs = targetSamples / 96
					for (const ch of taps[t]) {
						// Apply factory reset if checkbox is enabled
						if (shouldReset) {
							for (const resetCmd of FACTORY_RESET_COMMANDS) {
								const cmd = resetCmd.replace(/\{ch\}/g, ch)
								self._cmdSendLine(cmd)
							}
						}

						// Apply product integration if specified
						if (typeId) {
							self._cmdSendLine(`/processing/output/${ch}/delay_integration/type=${typeId}`)
						}
						if (startingPointCommands && Array.isArray(startingPointCommands)) {
							for (const cmd of startingPointCommands) {
								const finalCmd = cmd.replace(/\{ch\}/g, ch).replace(/\{\}/g, ch)
								self._cmdSendLine(finalCmd)
							}
						}

						// Apply end-fire delay
						self._cmdSendLine(`/processing/output/${ch}/delay=${targetSamples}`)
						self._applyOutputDelay(ch, targetSamples)

						// Apply link group assignment if specified
						const linkGroup = String(e.options?.endfire_link_group || '0')
						if (linkGroup !== '0') {
							const groupNum = Number(linkGroup)
							if (groupNum >= 1 && groupNum <= 8) {
								self._cmdSendLine(`/device/output/${ch}/output_link_group='${linkGroup}'`)
								// Update local state
								if (!self.outputLinkGroupAssign) self.outputLinkGroupAssign = {}
								self.outputLinkGroupAssign[ch] = groupNum
							}
						}

						const spLabel =
							speakerKey && speakerKey !== 'OFF'
								? ` [${speakerKey}${startingPointTitle ? ': ' + startingPointTitle : ''}]`
								: ''
						lines.push(`End-Fire T${t}: ch ${ch} = ${targetMs.toFixed(2)} ms${spLabel}`)
					}
				}

				// Apply link group bypass state if link group was assigned
				const linkGroup = String(e.options?.endfire_link_group || '0')
				if (linkGroup !== '0') {
					const groupNum = Number(linkGroup)
					if (groupNum >= 1 && groupNum <= 8) {
						// Enable = not bypassed (false), Disable = bypassed (true)
						const shouldBypass = e.options?.endfire_link_group_enable !== true
						self._cmdSendLine(`/device/output_link_group/${groupNum}/bypass='${shouldBypass}'`)
						// Update local state
						if (!self.outputLinkGroupBypass) self.outputLinkGroupBypass = {}
						self.outputLinkGroupBypass[groupNum] = shouldBypass
						if (typeof self.checkFeedbacks === 'function') {
							self.checkFeedbacks('output_link_group_bypassed')
							self.checkFeedbacks('output_link_group_assigned')
						}
						const groupStatus = shouldBypass ? 'Disabled (Bypassed)' : 'Enabled'
						lines.push(`Link Group ${groupNum}: ${groupStatus}`)
					}
				}

				if (lines.length) {
					const c_fps = c * 3.28084
					const T_F = (T * 9) / 5 + 32
					self.log?.(
						'info',
						[
							`End-Fire: f=${f} Hz | T=${e.options.temp_endfire}Â°${unitIn} (~${T.toFixed(1)}Â°C, c~${c.toFixed(1)} m/s ~ ${c_fps.toFixed(1)} ft/s) | perTap~${perTapMs.toFixed(2)} ms`,
							...lines,
						].join(' | '),
					)
				}

				try {
					self.updateActions?.()
				} catch {}
			} else if (mode === 'array') {
				// Execute Array logic
				try {
					const o = e.options
					const unitIn = o.tempUnit_array === 'F' ? 'F' : 'C'
					let T = Number.isFinite(Number(o.temp_array)) ? Number(o.temp_array) : 20
					if (unitIn === 'F') T = ((T - 32) * 5) / 9
					const c = speedOfSound_mps(T)

					self._arcassist = { T, c }
					try {
						self.updateActions?.()
					} catch {}

					if (o.startCh === '' || !Number.isFinite(Number(o.startCh))) {
						const c_fps = c * 3.28084
						const T_F = (T * 9) / 5 + 32
						self.log?.(
							'info',
							`Arc preview: c~${c.toFixed(1)} m/s (${c_fps.toFixed(1)} ft/s) at ${T.toFixed(1)} Â°C (${T_F.toFixed(1)} Â°F)`,
						)
						return
					}

					// Get product integration settings if specified
					const speakerKey = String(e.options?.array_speaker || '')
					let typeId = null
					let startingPointCommands = null
					let startingPointTitle = ''

					if (speakerKey && speakerKey !== 'OFF' && speakerKey !== '') {
						const speakerEntry = productIntegrationSpeakers.get(speakerKey)
						if (speakerEntry?.phases?.length > 0) {
							const fallbackPhase = speakerEntry.phases[0]
							typeId = fallbackPhase?.typeId ?? null
						}

						const startingPointOptionId = arraySpeakerStartingPointOption.get(speakerKey)
						if (startingPointOptionId) {
							const startingPointId = String(e.options?.[startingPointOptionId] || '').trim()
							if (startingPointId) {
								const entries = productIntegrationStartingPoints.get(speakerKey) || []
								const entry = entries.find((sp) => sp.id === startingPointId)
								if (entry && Array.isArray(entry.controlPoints) && entry.controlPoints.length > 0) {
									startingPointCommands = entry.controlPoints
									startingPointTitle = entry.title || ''
								}
							}
						}
					}

					const n = Math.max(1, Math.min(NUM_OUTPUTS, Number(o.numSubs)))
					const start = Math.max(1, Math.min(NUM_OUTPUTS, Number(o.startCh)))
					const end = Math.min(NUM_OUTPUTS, start + n - 1)

					const toMeters = o.units === 'ft' ? 0.3048 : 1.0
					const spacingM = Number(o.spacing) * toMeters
					const arcAngleDeg = Number(o.radius) || 0 // Treat "radius" field as arc angle in degrees

					const roundTo01 = (val) => Math.round(val / 0.01) * 0.01

					const msAtIndex = (i) => {
						if (arcAngleDeg === 0) return 0 // Straight line, no delays

						// Meyer Sound calculation method (matches Excel and official documentation)
						// Uses Cartesian distance calculation from arc positions to reference line

						const singleSplayDeg = arcAngleDeg / (n - 1)
						const singleSplayRad = (singleSplayDeg * Math.PI) / 180
						const AcC_virtual = -spacingM / singleSplayRad // Virtual acoustic center (negative radius)

						// Base angle offset for even/odd speaker count
						const baseAngleDeg = (n % 2 === 0) ? singleSplayDeg / 2 : 0

						// Reference point Y coordinate (straight line spacing)
						// For even count: starts at spacing/2, increments by spacing
						// T values go from high to low (T7=11, T8=9, ..., T12=1 for 6 speakers with 2m spacing)
						const T_base = (n % 2 === 0) ? spacingM / 2 : 0
						const T = T_base + ((n - 1 - i) * spacingM)

						// Speaker angle (decreases from high to low: 66Â°, 54Â°, 42Â°, 30Â°, 18Â°, 6Â° for 60Â° arc)
						const angleDeg = baseAngleDeg + ((n - 1 - i) * singleSplayDeg)
						const angleRad = (angleDeg * Math.PI) / 180

						// Speaker position on arc (Cartesian coordinates)
						const L = Math.abs(AcC_virtual) * Math.cos(angleRad) + AcC_virtual
						const M = Math.abs(AcC_virtual) * Math.sin(angleRad)

						// Reference point coordinates
						const S = 0

						// Euclidean distance from speaker to reference point
						const distance = Math.sqrt(Math.pow(S - L, 2) + Math.pow(T - M, 2))

						return (distance / c) * 1000
					}

					const raw = []
					for (let i = 0; i < n; i++) raw.push(msAtIndex(i))
					const minMs = Math.min(...raw)
					const relative = raw.map((v) => v - minMs)

					// Create symmetric delays: arc is symmetric, so we mirror the second half
					// Take last half (which has minimum delays) and create: lastHalf + reverse(lastHalf)
					const halfCount = Math.ceil(n / 2)
					const lastHalf = relative.slice(n - halfCount)

					const offsetsMs = [...lastHalf]
					// Append reverse, skipping last element for even count (to avoid duplicating center)
					for (let i = halfCount - (n % 2 === 0 ? 1 : 2); i >= 0; i--) {
						offsetsMs.push(lastHalf[i])
					}

					// Check if factory reset is enabled
					const shouldReset = e.options.reset_array === true

					const lines = []
					for (let i = 0; i < n; i++) {
						const ch = start + i

						// Apply factory reset if checkbox is enabled
						if (shouldReset) {
							for (const resetCmd of FACTORY_RESET_COMMANDS) {
								const cmd = resetCmd.replace(/\{ch\}/g, ch)
								self._cmdSendLine(cmd)
							}
						}

						// Apply product integration if specified
						if (typeId) {
							self._cmdSendLine(`/processing/output/${ch}/delay_integration/type=${typeId}`)
						}
						if (startingPointCommands && Array.isArray(startingPointCommands)) {
							for (const cmd of startingPointCommands) {
								const finalCmd = cmd.replace(/\{ch\}/g, ch).replace(/\{\}/g, ch)
								self._cmdSendLine(finalCmd)
							}
						}

						// Apply arc delay
						const targetMs = roundTo01(offsetsMs[i])
						self._setOutputDelayMs(ch, targetMs)

						// Apply link group assignment if specified
						const linkGroup = String(e.options?.array_link_group || '0')
						if (linkGroup !== '0') {
							const groupNum = Number(linkGroup)
							if (groupNum >= 1 && groupNum <= 8) {
								self._cmdSendLine(`/device/output/${ch}/output_link_group='${linkGroup}'`)
								// Update local state
								if (!self.outputLinkGroupAssign) self.outputLinkGroupAssign = {}
								self.outputLinkGroupAssign[ch] = groupNum
							}
						}

						const spLabel =
							speakerKey && speakerKey !== 'OFF'
								? ` [${speakerKey}${startingPointTitle ? ': ' + startingPointTitle : ''}]`
								: ''
						lines.push(`Arc: ch ${ch} = ${targetMs.toFixed(2)} ms${spLabel}`)
					}

					// Apply link group bypass state if link group was assigned
					const linkGroup = String(e.options?.array_link_group || '0')
					if (linkGroup !== '0') {
						const groupNum = Number(linkGroup)
						if (groupNum >= 1 && groupNum <= 8) {
							// Enable = not bypassed (false), Disable = bypassed (true)
							const shouldBypass = e.options?.array_link_group_enable !== true
							self._cmdSendLine(`/device/output_link_group/${groupNum}/bypass='${shouldBypass}'`)
							// Update local state
							if (!self.outputLinkGroupBypass) self.outputLinkGroupBypass = {}
							self.outputLinkGroupBypass[groupNum] = shouldBypass
							if (typeof self.checkFeedbacks === 'function') {
								self.checkFeedbacks('output_link_group_bypassed')
								self.checkFeedbacks('output_link_group_assigned')
							}
							const groupStatus = shouldBypass ? 'Disabled (Bypassed)' : 'Enabled'
							lines.push(`Link Group ${groupNum}: ${groupStatus}`)
						}
					}

					self.log?.(
						'info',
						[
							`Sub Arc: n=${n}, ch ${start}-${end}, spacing=${o.spacing}${o.units}, R=${o.radius}${o.units}, T=${o.temp_array}Â°${unitIn} (~${T.toFixed(1)}Â°C, c~${c.toFixed(1)} m/s)`,
							...lines,
						].join(' | '),
					)
				} catch (err) {
					self.log?.('error', `Arc delay failed: ${err?.message || err}`)
				}
			} else if (mode === 'gradient') {
				// Execute Gradient logic
				const speakerKey = String(e.options?.gradient_speaker || '')
				if (!speakerKey || speakerKey === 'OFF' || speakerKey === '') {
					self.log?.('warn', 'Please select a loudspeaker for Gradient mode')
					return
				}

				// Get the delay integration type ID
				let typeId = null
				const speakerEntry = productIntegrationSpeakers.get(speakerKey)

				// Use the first available phase for this speaker
				if (speakerEntry?.phases?.length > 0) {
					const fallbackPhase = speakerEntry.phases[0]
					typeId = fallbackPhase?.typeId ?? null
				}

				if (!typeId) {
					self.log?.('warn', `Invalid product integration selection for speaker ${speakerKey}`)
					return
				}

				const finalTypeId = String(typeId)
				const shouldReset = e.options.reset_gradient === true
				const lines = []

				// Process Front outputs
				const frontOptionId = gradientSpeakerStartingPointOption_Front.get(speakerKey)
				let frontStartingPointId = ''
				if (frontOptionId) {
					frontStartingPointId = String(e.options?.[frontOptionId] || '').trim()
				}

				const frontOutputsRaw = e.options.gradient_outputs_front
				const frontOutputs = Array.isArray(frontOutputsRaw)
					? frontOutputsRaw.map(Number).filter((ch) => Number.isFinite(ch) && ch >= 1 && ch <= NUM_OUTPUTS)
					: []

				// Process Reversed outputs
				const reversedOptionId = gradientSpeakerStartingPointOption_Reversed.get(speakerKey)
				let reversedStartingPointId = ''
				if (reversedOptionId) {
					reversedStartingPointId = String(e.options?.[reversedOptionId] || '').trim()
				}

				const reversedOutputsRaw = e.options.gradient_outputs_reversed
				const reversedOutputs = Array.isArray(reversedOutputsRaw)
					? reversedOutputsRaw.map(Number).filter((ch) => Number.isFinite(ch) && ch >= 1 && ch <= NUM_OUTPUTS)
					: []

				// Check for duplicate output selections
				const frontSet = new Set(frontOutputs)
				const reversedSet = new Set(reversedOutputs)
				const duplicates = frontOutputs.filter((ch) => reversedSet.has(ch))
				if (duplicates.length > 0) {
					self.log?.(
						'warn',
						`Warning: Outputs ${duplicates.join(', ')} are selected in both Front and Reversed. The Reversed setting will overwrite the Front setting for these channels.`,
					)
				}

				if (frontOutputs.length > 0) {
					let frontCommands = null
					let frontTitle = ''

					if (frontStartingPointId) {
						const entries = productIntegrationStartingPoints.get(speakerKey) || []
						const entry = entries.find((sp) => sp.id === frontStartingPointId)
						if (entry && Array.isArray(entry.controlPoints) && entry.controlPoints.length > 0) {
							frontCommands = entry.controlPoints
							frontTitle = entry.title || ''
						}
					}

					for (const ch of frontOutputs) {
						// Apply factory reset if checkbox is enabled
						if (shouldReset) {
							for (const resetCmd of FACTORY_RESET_COMMANDS) {
								const cmd = resetCmd.replace(/\{ch\}/g, ch)
								self._cmdSendLine(cmd)
							}
						}

						// Apply delay integration type
						self._cmdSendLine(`/processing/output/${ch}/delay_integration/type=${finalTypeId}`)

						// Apply starting point commands if any
						if (frontCommands && Array.isArray(frontCommands)) {
							for (const cmd of frontCommands) {
								const finalCmd = cmd.replace(/\{ch\}/g, ch).replace(/\{\}/g, ch)
								self._cmdSendLine(finalCmd)
							}
						}

						// Apply link group assignment if specified
						const linkGroup = String(e.options?.gradient_link_group || '0')
						if (linkGroup !== '0') {
							const groupNum = Number(linkGroup)
							if (groupNum >= 1 && groupNum <= 8) {
								self._cmdSendLine(`/device/output/${ch}/output_link_group='${linkGroup}'`)
								// Update local state
								if (!self.outputLinkGroupAssign) self.outputLinkGroupAssign = {}
								self.outputLinkGroupAssign[ch] = groupNum
							}
						}

						const spLabel = frontTitle ? ` (${frontTitle})` : ''
						lines.push(`Front ch ${ch}${spLabel}`)
					}
				}

				if (reversedOutputs.length > 0) {
					let reversedCommands = null
					let reversedTitle = ''

					if (reversedStartingPointId) {
						const entries = productIntegrationStartingPoints.get(speakerKey) || []
						const entry = entries.find((sp) => sp.id === reversedStartingPointId)
						if (entry && Array.isArray(entry.controlPoints) && entry.controlPoints.length > 0) {
							reversedCommands = entry.controlPoints
							reversedTitle = entry.title || ''
						}
					}

					for (const ch of reversedOutputs) {
						// Apply factory reset if checkbox is enabled
						if (shouldReset) {
							for (const resetCmd of FACTORY_RESET_COMMANDS) {
								const cmd = resetCmd.replace(/\{ch\}/g, ch)
								self._cmdSendLine(cmd)
							}
						}

						// Apply delay integration type
						self._cmdSendLine(`/processing/output/${ch}/delay_integration/type=${finalTypeId}`)

						// Apply starting point commands if any
						if (reversedCommands && Array.isArray(reversedCommands)) {
							for (const cmd of reversedCommands) {
								const finalCmd = cmd.replace(/\{ch\}/g, ch).replace(/\{\}/g, ch)
								self._cmdSendLine(finalCmd)
							}
						}

						// Apply link group assignment if specified
						const linkGroup = String(e.options?.gradient_link_group || '0')
						if (linkGroup !== '0') {
							const groupNum = Number(linkGroup)
							if (groupNum >= 1 && groupNum <= 8) {
								self._cmdSendLine(`/device/output/${ch}/output_link_group='${linkGroup}'`)
								// Update local state
								if (!self.outputLinkGroupAssign) self.outputLinkGroupAssign = {}
								self.outputLinkGroupAssign[ch] = groupNum
							}
						}

						const spLabel = reversedTitle ? ` (${reversedTitle})` : ''
						lines.push(`Reversed ch ${ch}${spLabel}`)
					}
				}

				// Apply link group bypass state if link group was assigned
				const linkGroup = String(e.options?.gradient_link_group || '0')
				if (linkGroup !== '0') {
					const groupNum = Number(linkGroup)
					if (groupNum >= 1 && groupNum <= 8) {
						// Enable = not bypassed (false), Disable = bypassed (true)
						const shouldBypass = e.options?.gradient_link_group_enable !== true
						self._cmdSendLine(`/device/output_link_group/${groupNum}/bypass='${shouldBypass}'`)
						// Update local state
						if (!self.outputLinkGroupBypass) self.outputLinkGroupBypass = {}
						self.outputLinkGroupBypass[groupNum] = shouldBypass
						if (typeof self.checkFeedbacks === 'function') {
							self.checkFeedbacks('output_link_group_bypassed')
							self.checkFeedbacks('output_link_group_assigned')
						}
						const groupStatus = shouldBypass ? 'Disabled (Bypassed)' : 'Enabled'
						lines.push(`Link Group ${groupNum}: ${groupStatus}`)
					}
				}

				if (lines.length > 0) {
					self.log?.('info', [`Gradient: ${speakerKey} (type ${finalTypeId})`, ...lines].join(' | '))
				} else {
					self.log?.('warn', 'No outputs selected for Gradient mode')
				}
			} else if (mode === 'array_endfire') {
				// Execute Array End-Fire logic (combines end-fire and array)
				try {
					const o = e.options

					// Get end-fire parameters
					const f = Math.max(1e-6, Number(o.freq_arrayendfire) || 80)
					const depth = Math.min(8, Math.max(2, Number(o.depth_arrayendfire) || 2))

					// Get temperature and calculate speed of sound
					const unitIn = o.tempUnit_arrayendfire === 'F' ? 'F' : 'C'
					let T = Number.isFinite(Number(o.temp_arrayendfire)) ? Number(o.temp_arrayendfire) : 20
					if (unitIn === 'F') T = ((T - 32) * 5) / 9
					const c = speedOfSound_mps(T)

					// Store for variable updates
					const spacing_m = c / (4 * f)
					self._subassist = { spacing_m, T, c }
					self._arcassist = { T, c }
					self.setVariableValues?.({
						subassist_spacing_ft: (spacing_m * 3.28084).toFixed(2),
						subassist_spacing_m: spacing_m.toFixed(3),
					})

					try {
						self.updateActions?.()
					} catch {}

					// Get array parameters
					const toMeters = o.units_arrayendfire === 'ft' ? 0.3048 : 1.0
					const spacingM = Number(o.spacing_arrayendfire) * toMeters
					const arcAngleDeg = Number(o.radius_arrayendfire) || 0 // Treat "radius" field as arc angle in degrees
					const numSubs = Math.max(1, Math.min(NUM_OUTPUTS, Number(o.numSubs_arrayendfire)))

					// Get starting channels for each row
					const rowLabels = ['front', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth']
					const rowStartChannels = []
					for (let rowIdx = 0; rowIdx < depth; rowIdx++) {
						const key = `startCh_${rowLabels[rowIdx]}_arrayendfire`
						const startCh = Number(o[key])
						if (Number.isFinite(startCh) && startCh >= 1 && startCh <= NUM_OUTPUTS) {
							rowStartChannels.push(startCh)
						} else {
							rowStartChannels.push(null)
						}
					}

					// Calculate end-fire delays per row
					const roundTo01 = (val) => Math.round(val / 0.01) * 0.01
					const perTapMs = roundTo01(1000 / (4 * f))
					const perTapSamples = Math.round(perTapMs * 96)

					// Calculate array arc delays (same for all rows)
					const msAtIndex = (i) => {
						if (arcAngleDeg === 0) return 0 // Straight line, no delays

						// Meyer Sound calculation method (matches Excel and official documentation)
						// Uses Cartesian distance calculation from arc positions to reference line

						const singleSplayDeg = arcAngleDeg / (numSubs - 1)
						const singleSplayRad = (singleSplayDeg * Math.PI) / 180
						const AcC_virtual = -spacingM / singleSplayRad // Virtual acoustic center (negative radius)

						// Base angle offset for even/odd speaker count
						const baseAngleDeg = (numSubs % 2 === 0) ? singleSplayDeg / 2 : 0

						// Reference point Y coordinate (straight line spacing)
						// For even count: starts at spacing/2, increments by spacing
						// T values go from high to low (T7=11, T8=9, ..., T12=1 for 6 speakers with 2m spacing)
						const T_base = (numSubs % 2 === 0) ? spacingM / 2 : 0
						const T = T_base + ((numSubs - 1 - i) * spacingM)

						// Speaker angle (decreases from high to low: 66Â°, 54Â°, 42Â°, 30Â°, 18Â°, 6Â° for 60Â° arc)
						const angleDeg = baseAngleDeg + ((numSubs - 1 - i) * singleSplayDeg)
						const angleRad = (angleDeg * Math.PI) / 180

						// Speaker position on arc (Cartesian coordinates)
						const L = Math.abs(AcC_virtual) * Math.cos(angleRad) + AcC_virtual
						const M = Math.abs(AcC_virtual) * Math.sin(angleRad)

						// Reference point coordinates
						const S = 0

						// Euclidean distance from speaker to reference point
						const distance = Math.sqrt(Math.pow(S - L, 2) + Math.pow(T - M, 2))

						return (distance / c) * 1000
					}

					const raw = []
					for (let i = 0; i < numSubs; i++) raw.push(msAtIndex(i))
					const minMs = Math.min(...raw)
					const relative = raw.map((v) => v - minMs)

					// Create symmetric delays: arc is symmetric, so we mirror the second half
					// Take last half (which has minimum delays) and create: lastHalf + reverse(lastHalf)
					const halfCount = Math.ceil(numSubs / 2)
					const lastHalf = relative.slice(numSubs - halfCount)

					const arcOffsetsMs = [...lastHalf]
					// Append reverse, skipping last element for even count (to avoid duplicating center)
					for (let i = halfCount - (numSubs % 2 === 0 ? 1 : 2); i >= 0; i--) {
						arcOffsetsMs.push(lastHalf[i])
					}

					// Get product integration settings if specified
					const speakerKey = String(o?.arrayendfire_speaker || '')
					let typeId = null
					let startingPointCommands = null
					let startingPointTitle = ''

					if (speakerKey && speakerKey !== 'OFF' && speakerKey !== '') {
						const speakerEntry = productIntegrationSpeakers.get(speakerKey)
						if (speakerEntry?.phases?.length > 0) {
							const fallbackPhase = speakerEntry.phases[0]
							typeId = fallbackPhase?.typeId ?? null
						}

						const startingPointOptionId = arrayendfireSpeakerStartingPointOption.get(speakerKey)
						if (startingPointOptionId) {
							const startingPointId = String(o?.[startingPointOptionId] || '').trim()
							if (startingPointId) {
								const entries = productIntegrationStartingPoints.get(speakerKey) || []
								const entry = entries.find((sp) => sp.id === startingPointId)
								if (entry && Array.isArray(entry.controlPoints) && entry.controlPoints.length > 0) {
									startingPointCommands = entry.controlPoints
									startingPointTitle = entry.title || ''
								}
							}
						}
					}

					// Check if factory reset is enabled
					const shouldReset = o.reset_arrayendfire === true

					const lines = []

					// Apply combined delays to each row
					for (let rowIdx = 0; rowIdx < depth; rowIdx++) {
						const rowStartCh = rowStartChannels[rowIdx]
						if (rowStartCh === null) continue

						const endfireMs = (rowIdx * perTapSamples) / 96

						// Process each sub in this row
						for (let subIdx = 0; subIdx < numSubs; subIdx++) {
							const ch = rowStartCh + subIdx
							if (ch > NUM_OUTPUTS) break

							// Get the arc delay for this position in the array
							const arcMs = subIdx < arcOffsetsMs.length ? arcOffsetsMs[subIdx] : 0

							// Combined delay = end-fire delay + arc delay
							const combinedMs = roundTo01(endfireMs + arcMs)

							// Apply factory reset if checkbox is enabled
							if (shouldReset) {
								for (const resetCmd of FACTORY_RESET_COMMANDS) {
									const cmd = resetCmd.replace(/\{ch\}/g, ch)
									self._cmdSendLine(cmd)
								}
							}

							// Apply product integration if specified
							if (typeId) {
								self._cmdSendLine(`/processing/output/${ch}/delay_integration/type=${typeId}`)
							}
							if (startingPointCommands && Array.isArray(startingPointCommands)) {
								for (const cmd of startingPointCommands) {
									const finalCmd = cmd.replace(/\{ch\}/g, ch).replace(/\{\}/g, ch)
									self._cmdSendLine(finalCmd)
								}
							}

							// Apply combined delay
							self._setOutputDelayMs(ch, combinedMs)

							// Apply link group assignment if specified
							const linkGroup = String(o?.arrayendfire_link_group || '0')
							if (linkGroup !== '0') {
								const groupNum = Number(linkGroup)
								if (groupNum >= 1 && groupNum <= 8) {
									self._cmdSendLine(`/device/output/${ch}/output_link_group='${linkGroup}'`)
									// Update local state
									if (!self.outputLinkGroupAssign) self.outputLinkGroupAssign = {}
									self.outputLinkGroupAssign[ch] = groupNum
								}
							}

							const spLabel =
								speakerKey && speakerKey !== 'OFF'
									? ` [${speakerKey}${startingPointTitle ? ': ' + startingPointTitle : ''}]`
									: ''
							const rowName = rowLabels[rowIdx].charAt(0).toUpperCase() + rowLabels[rowIdx].slice(1)
							lines.push(
								`${rowName} row: ch ${ch} = ${combinedMs.toFixed(2)} ms (EF: ${endfireMs.toFixed(2)} + Arc: ${arcMs.toFixed(2)})${spLabel}`,
							)
						}
					}

					// Apply link group bypass state if link group was assigned
					const linkGroup = String(o?.arrayendfire_link_group || '0')
					if (linkGroup !== '0') {
						const groupNum = Number(linkGroup)
						if (groupNum >= 1 && groupNum <= 8) {
							// Enable = not bypassed (false), Disable = bypassed (true)
							const shouldBypass = o?.arrayendfire_link_group_enable !== true
							self._cmdSendLine(`/device/output_link_group/${groupNum}/bypass='${shouldBypass}'`)
							// Update local state
							if (!self.outputLinkGroupBypass) self.outputLinkGroupBypass = {}
							self.outputLinkGroupBypass[groupNum] = shouldBypass
							if (typeof self.checkFeedbacks === 'function') {
								self.checkFeedbacks('output_link_group_bypassed')
								self.checkFeedbacks('output_link_group_assigned')
							}
							const groupStatus = shouldBypass ? 'Disabled (Bypassed)' : 'Enabled'
							lines.push(`Link Group ${groupNum}: ${groupStatus}`)
						}
					}

					if (lines.length) {
						const c_fps = c * 3.28084
						const T_F = (T * 9) / 5 + 32
						self.log?.(
							'info',
							[
								`Array End-Fire: f=${f} Hz, depth=${depth} rows, ${numSubs} subs/row, spacing=${o.spacing_arrayendfire}${o.units_arrayendfire}, R=${o.radius_arrayendfire}${o.units_arrayendfire} | T=${o.temp_arrayendfire}Â°${unitIn} (~${T.toFixed(1)}Â°C, c~${c.toFixed(1)} m/s ~ ${c_fps.toFixed(1)} ft/s) | perRow~${perTapMs.toFixed(2)} ms`,
								...lines,
							].join(' | '),
						)
					} else {
						self.log?.('warn', 'No rows configured for Array End-Fire mode')
					}
				} catch (err) {
					self.log?.('error', `Array End-Fire failed: ${err?.message || err}`)
				}
			}
		},
	}

	// =========================
	// ===== LINE ARRAY DESIGN ======
	// =========================

	// Get combinations data first (needed by multiple sections below)
	const lineArrayCombinations = STARTING_POINTS_SOURCE.combinations || {}

	// Build phase options for line array - one option per speaker with phases
	const lineArrayPhaseOptions = []
	for (const speaker of productIntegrationSpeakers.values()) {
		if (!speaker.phases || speaker.phases.length === 0) continue

		const speakerKey = speaker.key
		const phaseChoices = speaker.phases.map(p => ({ id: p.id, label: p.label }))
		const safeSpeakerJson = JSON.stringify(speakerKey)

		lineArrayPhaseOptions.push({
			type: 'dropdown',
			id: `phase_for_${speakerKey}`,
			label: 'Phase Curve',
			default: speaker.phases[0]?.id || '',
			choices: phaseChoices,
			isVisible: new Function('options', `return options.primary_speaker === ${safeSpeakerJson};`)
		})
	}

	// Build starting point options for line array - primary
	const lineArrayPrimaryStartingPointOptions = []
	for (const [canonicalKey, entries] of productIntegrationStartingPoints.entries()) {
		if (!entries || entries.length === 0) continue

		// Find the speaker with this canonical key
		let speakerKey = null
		for (const speaker of productIntegrationSpeakers.values()) {
			if (canonicalizeSpeakerKey(speaker.key) === canonicalKey) {
				speakerKey = speaker.key
				break
			}
		}
		if (!speakerKey) continue

		const choices = [
			{ id: '', label: '-- None --' },
			...entries.map(sp => ({ id: sp.id, label: sp.title }))
		]
		const safeSpeakerJson = JSON.stringify(speakerKey)

		lineArrayPrimaryStartingPointOptions.push({
			type: 'dropdown',
			id: `primary_sp_for_${speakerKey}`,
			label: 'Starting point (primary)',
			default: '',
			choices: choices,
			isVisible: new Function('options', `return options.primary_speaker === ${safeSpeakerJson};`)
		})
	}

	// Build starting point options for line array - secondary
	const lineArraySecondaryStartingPointOptions = []
	for (const [canonicalKey, entries] of productIntegrationStartingPoints.entries()) {
		if (!entries || entries.length === 0) continue

		// Find the speaker with this canonical key
		let speakerKey = null
		for (const speaker of productIntegrationSpeakers.values()) {
			if (canonicalizeSpeakerKey(speaker.key) === canonicalKey) {
				speakerKey = speaker.key
				break
			}
		}
		if (!speakerKey) continue

		const choices = [
			{ id: '', label: '-- None --' },
			...entries.map(sp => ({ id: sp.id, label: sp.title }))
		]
		const safeSpeakerJson = JSON.stringify(speakerKey)

		// Build visibility check that checks if this speaker is selected as secondary
		// We need to check the secondary speaker option for the currently selected primary
		const visibilityCode = `
			if (!options.mixed_array) return false;
			const primarySpeaker = String(options.primary_speaker || '');
			if (!primarySpeaker) return false;
			const secondaryOptionId = 'secondary_for_' + primarySpeaker;
			const selectedSecondary = options[secondaryOptionId];
			return selectedSecondary === ${safeSpeakerJson};
		`

		lineArraySecondaryStartingPointOptions.push({
			type: 'dropdown',
			id: `secondary_sp_for_${speakerKey}`,
			label: 'Starting point (secondary)',
			default: '',
			choices: choices,
			isVisible: new Function('options', visibilityCode)
		})
	}

	// Build secondary speaker options - one per primary speaker that has a valid combination
	const lineArraySecondaryOptions = []
	for (const [primaryKey, combo] of Object.entries(lineArrayCombinations)) {
		if (!combo || !combo.secondary) continue

		const safePrimaryJson = JSON.stringify(primaryKey)
		const secondarySpeaker = combo.secondary

		lineArraySecondaryOptions.push({
			type: 'dropdown',
			id: `secondary_for_${primaryKey}`,
			label: 'Secondary loudspeaker',
			default: secondarySpeaker,
			choices: [
				{ id: primaryKey, label: primaryKey },
				{ id: secondarySpeaker, label: secondarySpeaker }
			],
			isVisible: new Function('options', `return options.mixed_array === true && options.primary_speaker === ${safePrimaryJson};`)
		})
	}

	actions['line_array_design'] = {
		name: 'Line Array Design',
		options: [
			{
				type: 'dropdown',
				id: 'primary_speaker',
				label: 'Primary loudspeaker',
				default: '',
				choices: lineArraySpeakerChoices,
			},
			{
				type: 'number',
				id: 'primary_elements',
				label: 'Number of elements (primary)',
				default: 12,
				min: 1,
				max: 64,
			},
			{
				type: 'number',
				id: 'elements_per_output',
				label: 'Number of elements per output',
				default: 1,
				min: 1,
				max: 2,
			},
			{
				type: 'dropdown',
				id: 'start_output',
				label: 'Starting output',
				default: '1',
				choices: rangeChoices(NUM_OUTPUTS, 'Output '),
			},

			// Spread phase options - one per speaker
			...lineArrayPhaseOptions,

			// Spread primary starting point options - one per speaker
			...lineArrayPrimaryStartingPointOptions,

			{
				type: 'checkbox',
				id: 'mixed_array',
				label: 'Mixed array',
				default: false,
				tooltip: 'Enable to add a secondary loudspeaker type with delay compensation',
				isVisible: new Function('options', `
					const primarySpeaker = String(options.primary_speaker || '');
					if (!primarySpeaker) return false;
					const validPrimarySpeakers = ${JSON.stringify(Object.keys(lineArrayCombinations))};
					return validPrimarySpeakers.includes(primarySpeaker);
				`)
			},
			// Spread secondary speaker options - one per primary speaker
			...lineArraySecondaryOptions,
			{
				type: 'number',
				id: 'secondary_elements',
				label: 'Number of elements (secondary)',
				default: 6,
				min: 1,
				max: 64,
				isVisible: new Function('options', `
					if (!options.mixed_array) return false;
					const primarySpeaker = String(options.primary_speaker || '');
					if (!primarySpeaker) return false;
					const validPrimarySpeakers = ${JSON.stringify(Object.keys(lineArrayCombinations))};
					return validPrimarySpeakers.includes(primarySpeaker);
				`)
			},

			// Spread secondary starting point options - one per speaker
			...lineArraySecondaryStartingPointOptions,

			// Link Group options
			{
				type: 'dropdown',
				id: 'link_group',
				label: 'Assign to Output Link Group',
				default: '0',
				choices: [
					{ id: '0', label: 'None (Unassigned)' },
					{ id: '1', label: 'Link Group 1' },
					{ id: '2', label: 'Link Group 2' },
					{ id: '3', label: 'Link Group 3' },
					{ id: '4', label: 'Link Group 4' },
					{ id: '5', label: 'Link Group 5' },
					{ id: '6', label: 'Link Group 6' },
					{ id: '7', label: 'Link Group 7' },
					{ id: '8', label: 'Link Group 8' },
				],
			},
			{
				type: 'checkbox',
				id: 'link_group_enable',
				label: 'Enable the selected Output Link Group',
				default: true,
				isVisible: (o) => o.link_group !== '0',
			},
			{
				type: 'checkbox',
				id: 'reset_line_array',
				label: 'Reset channels to factory defaults before applying',
				default: false,
			},

			// ===== LMBC OPTIONS =====
			{
				type: 'checkbox',
				id: 'enable_lmbc',
				label: 'Enable LMBC (Low-Mid Beam Control)',
				default: false,
				tooltip: 'Enable Low-Mid Beam Control for this line array',
				isVisible: (o) => o.primary_speaker !== 'M1D',
			},
			{
				type: 'dropdown',
				id: 'lmbc_array_index',
				label: 'LMBC: Beam Control Array',
				default: '1',
				choices: [
					{ id: '1', label: 'Beam Control Array 1' },
					{ id: '2', label: 'Beam Control Array 2' },
					{ id: '3', label: 'Beam Control Array 3' },
					{ id: '4', label: 'Beam Control Array 4' },
				],
				tooltip: 'Select which beam control array to configure (1-4)',
				isVisible: (o) => o.enable_lmbc === true && o.primary_speaker !== 'M1D',
			},
			{
				type: 'number',
				id: 'lmbc_beam_angle',
				label: 'LMBC: Total Angle (degrees)',
				default: 15,
				min: 10,
				max: 99,
				tooltip: 'Total beam angle in degrees (10-99)',
				isVisible: (o) => o.enable_lmbc === true && o.primary_speaker !== 'M1D',
			},
			{
				type: 'dropdown',
				id: 'lmbc_control_type',
				label: 'LMBC: Type',
				default: '0',
				choices: [
					{ id: '0', label: 'Spread' },
					{ id: '1', label: 'Steer Up' },
				],
				tooltip: 'Beam control type: Spread or Steer Up',
				isVisible: (o) => o.enable_lmbc === true && o.primary_speaker !== 'M1D',
			},
			{
				type: 'number',
				id: 'lmbc_starting_element',
				label: 'LMBC: Starting Element',
				default: 1,
				min: 1,
				max: 32,
				tooltip: 'First element number in the array (1-32)',
				isVisible: (o) => o.enable_lmbc === true && o.primary_speaker !== 'M1D',
			},
			{
				type: 'static-text',
				id: 'lmbc_status_info',
				label: 'LMBC Status',
				value: lmbcStatusPreview(self, 1),
				isVisible: (o) => o.enable_lmbc === true && o.primary_speaker !== 'M1D',
			},
		],
		callback: async (e) => {
			try {
				const primarySpeaker = String(e.options.primary_speaker || '')
				const primaryElements = Number(e.options.primary_elements) || 12
				const elementsPerOutput = Number(e.options.elements_per_output) || 1
				const startOutput = Number(e.options.start_output) || 1
				const mixedArray = e.options.mixed_array === true

				// Get secondary speaker from the dynamic option ID
				const secondarySpeakerOptionId = `secondary_for_${primarySpeaker}`
				const secondarySpeaker = String(e.options[secondarySpeakerOptionId] || '')
				const secondaryElements = Number(e.options.secondary_elements) || 0

				if (!primarySpeaker) {
					self.log?.('warn', 'Line Array Design: No primary speaker selected')
					return
				}

				// Calculate total elements (primary + secondary if mixed array)
				const totalElements = mixedArray && secondarySpeaker ? primaryElements + secondaryElements : primaryElements

				// Calculate number of outputs needed
				const numOutputs = Math.ceil(totalElements / elementsPerOutput)

				// Check if we have enough outputs
				if (startOutput + numOutputs - 1 > NUM_OUTPUTS) {
					self.log?.(
						'warn',
						`Line Array Design: Not enough outputs. Need ${numOutputs} outputs starting from ${startOutput}, but only ${NUM_OUTPUTS - startOutput + 1} available`,
					)
					return
				}

				const commands = []

				// Check if factory reset is enabled
				const shouldReset = e.options.reset_line_array === true

				// Calculate delay compensation for mixed array using combinations data
				let primaryDelayMs = 0
				let secondaryDelayMs = 0
				if (mixedArray && secondarySpeaker) {
					const combinations = STARTING_POINTS_SOURCE.combinations || {}
					const combo = combinations[primarySpeaker]
					if (combo && combo.secondary === secondarySpeaker) {
						primaryDelayMs = combo.primaryDelayMs || 0
						secondaryDelayMs = combo.secondaryDelayMs || 0
					} else {
						// Fallback to old compensation method
						const compensation = STARTING_POINTS_SOURCE.compensation || {}
						const compData = compensation[secondarySpeaker]
						if (compData && typeof compData.delayMs === 'number') {
							primaryDelayMs = compData.delayMs
							secondaryDelayMs = 0
						}
					}
				}

				// Calculate how many outputs are for primary vs secondary
				const primaryOutputs = Math.ceil(primaryElements / elementsPerOutput)
				const secondaryOutputs = mixedArray && secondarySpeaker ? Math.ceil(secondaryElements / elementsPerOutput) : 0

				// Helper function to get product integration type ID and starting points
				const getSpeakerSettings = (speakerKey, isPrimary) => {
					// Get phase from the phase option for the primary speaker (shared for whole array)
					const phaseOptionId = `phase_for_${primarySpeaker}`
					const requestedPhase = String(e.options?.[phaseOptionId] || '')

					let typeId = null
					const speakerEntry = productIntegrationSpeakers.get(speakerKey)
					let phaseKey = requestedPhase
					if ((!phaseKey || phaseKey === '') && speakerEntry?.phases?.[0]?.id) {
						phaseKey = speakerEntry.phases[0].id
					}

					if (typeof phaseKey === 'string' && phaseKey.length > 0) {
						typeId = productIntegrationLookup.get(`${speakerKey}|${phaseKey}`)
						if (!typeId && speakerEntry?.phases) {
							const exact = speakerEntry.phases.find((p) => p.id === phaseKey)
							if (exact?.typeId) typeId = exact.typeId
						}
					}

					if (!typeId && speakerEntry?.phases?.length > 0) {
						const fallbackPhase = speakerEntry.phases[0]
						phaseKey = fallbackPhase?.id ?? ''
						typeId = fallbackPhase?.typeId ?? null
					}

					// Get starting point commands
					let startingPointCommands = null
					let startingPointTitle = ''
					const startingPointOptionId = isPrimary ? `primary_sp_for_${speakerKey}` : `secondary_sp_for_${speakerKey}`
					const selectionId = String(e.options?.[startingPointOptionId] ?? '').trim()
					if (selectionId) {
						const canonicalKey = canonicalizeSpeakerKey(speakerKey)
						const entries = productIntegrationStartingPoints.get(canonicalKey) || []
						const entry = entries.find((sp) => sp.id === selectionId)
						if (entry && Array.isArray(entry.controlPoints) && entry.controlPoints.length > 0) {
							startingPointCommands = entry.controlPoints
							startingPointTitle = entry.title || ''
						}
					}

					return { typeId, startingPointCommands, startingPointTitle }
				}

				// Get settings for primary speaker
				const primarySettings = getSpeakerSettings(primarySpeaker, true)

				// Get settings for secondary speaker if mixed array
				let secondarySettings = null
				if (mixedArray && secondarySpeaker) {
					secondarySettings = getSpeakerSettings(secondarySpeaker, false)
				}

				// Apply settings to each output
				for (let i = 0; i < numOutputs; i++) {
					const outputNum = startOutput + i
					if (outputNum > NUM_OUTPUTS) break

					// Determine if this output is primary or secondary
					const isPrimary = i < primaryOutputs
					const speakerType = isPrimary ? primarySpeaker : secondarySpeaker
					const settings = isPrimary ? primarySettings : secondarySettings

					// Calculate element range for this output
					let firstElement, lastElement
					if (isPrimary) {
						firstElement = i * elementsPerOutput + 1
						lastElement = Math.min((i + 1) * elementsPerOutput, primaryElements)
					} else {
						const secondaryIndex = i - primaryOutputs
						firstElement = secondaryIndex * elementsPerOutput + 1
						lastElement = Math.min((secondaryIndex + 1) * elementsPerOutput, secondaryElements)
					}
					const elementsOnThisOutput = lastElement - firstElement + 1

					// Apply factory reset if checkbox is enabled
					if (shouldReset) {
						for (const resetCmd of FACTORY_RESET_COMMANDS) {
							const cmd = resetCmd.replace(/\{ch\}/g, outputNum)
							self._cmdSendLine(cmd)
						}
					}

					// Apply product integration type
					if (settings?.typeId) {
						self._cmdSendLine(`/processing/output/${outputNum}/delay_integration/type=${settings.typeId}`)
					}

					// Apply starting point commands
					if (settings?.startingPointCommands && settings.startingPointCommands.length) {
						for (const rawCmd of settings.startingPointCommands) {
							let cmd = String(rawCmd || '').trim()
							if (!cmd) continue
							if (cmd.includes('{}')) {
								cmd = cmd.replace(/\{\}/g, outputNum)
							} else if (cmd.includes('{ch}')) {
								cmd = cmd.replace(/\{ch\}/gi, outputNum)
							}
							self._cmdSendLine(cmd)
						}
					}

					// Set delay with compensation if needed
					const delayMs = isPrimary ? primaryDelayMs : secondaryDelayMs
					if (delayMs > 0) {
						self._cmdSendLine(`/processing/output/${outputNum}/delay=${Math.round(delayMs * 96)}`)
					}

					// Apply link group assignment if specified
					const linkGroup = String(e.options?.link_group || '0')
					if (linkGroup !== '0') {
						const groupNum = Number(linkGroup)
						if (groupNum >= 1 && groupNum <= 8) {
							self._cmdSendLine(`/device/output/${outputNum}/output_link_group='${linkGroup}'`)
							// Update local state
							if (!self.outputLinkGroupAssign) self.outputLinkGroupAssign = {}
							self.outputLinkGroupAssign[outputNum] = groupNum
						}
					}

					const startingPointInfo = settings?.startingPointTitle ? ` | ${settings.startingPointTitle}` : ''
					const delayInfo = delayMs > 0 ? ` | ${delayMs.toFixed(2)}ms delay` : ''
					self.log?.(
						'info',
						`Line Array Design: Output ${outputNum} - ${speakerType} Elements ${firstElement}-${lastElement} (${elementsOnThisOutput} element${elementsOnThisOutput > 1 ? 's' : ''})${delayInfo}${startingPointInfo}`,
					)
				}

				// Apply link group bypass state if link group was assigned
				const linkGroup = String(e.options?.link_group || '0')
				if (linkGroup !== '0') {
					const groupNum = Number(linkGroup)
					if (groupNum >= 1 && groupNum <= 8) {
						// Enable = not bypassed (false), Disable = bypassed (true)
						const shouldBypass = e.options?.link_group_enable !== true
						self._cmdSendLine(`/device/output_link_group/${groupNum}/bypass='${shouldBypass}'`)
						// Update local state
						if (!self.outputLinkGroupBypass) self.outputLinkGroupBypass = {}
						self.outputLinkGroupBypass[groupNum] = shouldBypass
						if (typeof self.checkFeedbacks === 'function') {
							self.checkFeedbacks('output_link_group_bypassed')
							self.checkFeedbacks('output_link_group_assigned')
						}
						const groupStatus = shouldBypass ? 'Disabled (Bypassed)' : 'Enabled'
						self.log?.('info', `Line Array Design: Link Group ${groupNum} - ${groupStatus}`)
					}
				}

				// Send commands
				if (commands.length > 0) {
					await self.sendOsc(commands)
				}

				// Apply LMBC configuration if enabled
				if (e.options.enable_lmbc === true) {
					const arrayIndex = Number(e.options.lmbc_array_index) || 1 // User-selected beam control array (1-4)
					const beamAngle = Math.max(10, Math.min(99, Number(e.options.lmbc_beam_angle) || 15))
					const bypass = 'false' // Always active (not bypassed)
					const controlType = e.options.lmbc_control_type === '1' ? '1' : '0'
					const lmbcStartingElement = Math.max(1, Math.min(32, Number(e.options.lmbc_starting_element) || 1))

					// Map primary speaker to product type
					const productTypeMap = {
						'LEO-M': '0',
						'LYON': '1',
						'LEOPARD': '2',
						'MICA': '3',
						'MELODIE': '4',
						'MINA': '5',
						'LINA': '5', // Same as MINA
						'MILO': '6',
						'M3D': '7',
						'M2D': '8',
						'PANTHER': '9',
					}
					const productType = productTypeMap[primarySpeaker] || '0'

					const lmbcCommands = [
						`/processing/beam_control_array/${arrayIndex}/beam_angle='${beamAngle}'`,
						`/processing/beam_control_array/${arrayIndex}/bypass='${bypass}'`,
						`/processing/beam_control_array/${arrayIndex}/control_type='${controlType}'`,
						`/processing/beam_control_array/${arrayIndex}/elements_per_output='${elementsPerOutput}'`,
						`/processing/beam_control_array/${arrayIndex}/number_of_elements='${totalElements}'`,
						`/processing/beam_control_array/${arrayIndex}/product_type='${productType}'`,
						`/processing/beam_control_array/${arrayIndex}/starting_output_number='${startOutput}'`,
						`/processing/beam_control_array/${arrayIndex}/starting_element='${lmbcStartingElement}'`,
					]

					// Send LMBC commands
					for (const cmd of lmbcCommands) {
						self._cmdSendLine(cmd)
					}

					const lmbcTypeLabel = controlType === '1' ? 'Steer Up' : 'Spread'
					self.log?.(
						'info',
						`Line Array Design: LMBC Array ${arrayIndex} configured - Active, ${lmbcTypeLabel}, ${beamAngle}Â° beam angle, ${totalElements} elements starting at element ${lmbcStartingElement}`,
					)
				}

				const mixedArrayInfo = mixedArray && secondarySpeaker ? ` | Mixed array with ${secondarySpeaker}` : ''
				const linkGroupInfo = linkGroup !== '0' ? ` | Link Group ${linkGroup}` : ''
				const lmbcInfo = e.options.enable_lmbc === true ? ' | LMBC Enabled' : ''
				self.log?.(
					'info',
					`Line Array Design: ${primarySpeaker} | ${totalElements} elements, ${elementsPerOutput} per output | Starting at Output ${startOutput} (${numOutputs} outputs)${mixedArrayInfo}${linkGroupInfo}${lmbcInfo}`,
				)
			} catch (err) {
				self.log?.('error', `Line Array Design failed: ${err?.message || err}`)
			}
		},
	}

	// =========================
	// ===== LMBC (Low-Mid Beam Control) =====
	// =========================

	function lmbcStatusPreview(self, arrayIndex = 1) {
		const status = self?.beamControlStatus?.[arrayIndex]
		if (!status || status.errorCode === undefined) {
			return `-- Waiting for status from Galaxy (Array ${arrayIndex}) --`
		}
		const errorMsg = status.errorString || ''
		if (errorMsg && errorMsg.trim() !== '') {
			return errorMsg
		}
		return '-- No error message --'
	}

	actions['lmbc_configure'] = {
		name: 'LMBC: Configure Low-Mid Beam Control',
		options: [
			{
				type: 'dropdown',
				id: 'array_index',
				label: 'Beam Control Array',
				default: '1',
				choices: [
					{ id: '1', label: 'Beam Control Array 1' },
					{ id: '2', label: 'Beam Control Array 2' },
					{ id: '3', label: 'Beam Control Array 3' },
					{ id: '4', label: 'Beam Control Array 4' },
				],
				tooltip: 'Select which beam control array to configure (1-4)',
			},
			{
				type: 'number',
				id: 'beam_angle',
				label: 'Total Angle (degrees)',
				default: 15,
				min: 10,
				max: 99,
				tooltip: 'Total beam angle in degrees (10-99)',
			},
			{
				type: 'number',
				id: 'elements_per_output',
				label: 'Elements Per Output',
				default: 1,
				min: 1,
				max: 2,
				tooltip: 'Number of elements per output (1 or 2)',
			},
			{
				type: 'dropdown',
				id: 'product_type',
				label: 'Loudspeaker Model',
				default: '0',
				choices: [
					{ id: '0', label: 'LEO-M' },
					{ id: '1', label: 'LYON' },
					{ id: '2', label: 'LEOPARD' },
					{ id: '3', label: 'MICA' },
					{ id: '4', label: 'MELODIE' },
					{ id: '5', label: 'MINA' },
					{ id: '6', label: 'MILO' },
					{ id: '7', label: 'M3D' },
					{ id: '8', label: 'M2D' },
					{ id: '9', label: 'PANTHER' },
				],
				tooltip: 'Select the loudspeaker model for beam control',
			},
			{
				type: 'dropdown',
				id: 'bypass',
				label: 'Bypass',
				default: 'false',
				choices: [
					{ id: 'false', label: 'Active (Not Bypassed)' },
					{ id: 'true', label: 'Bypassed' },
				],
				tooltip: 'Enable or bypass the beam control',
			},
			{
				type: 'dropdown',
				id: 'control_type',
				label: 'Type',
				default: '0',
				choices: [
					{ id: '0', label: 'Spread' },
					{ id: '1', label: 'Steer Up' },
				],
				tooltip: 'Beam control type: Spread or Steer Up',
			},
			{
				type: 'number',
				id: 'number_of_elements',
				label: 'Number of Elements',
				default: 12,
				min: 8,
				max: 32,
				tooltip: 'Total number of elements in the array (8-32)',
			},
			{
				type: 'number',
				id: 'starting_output',
				label: 'Starting Output',
				default: 1,
				min: 1,
				max: NUM_OUTPUTS,
				tooltip: 'First output channel for the array',
			},
			{
				type: 'number',
				id: 'starting_element',
				label: 'Starting Element',
				default: 1,
				min: 1,
				max: 32,
				tooltip: 'First element number in the array (1-32)',
			},
			{
				type: 'static-text',
				id: 'lmbc_status_info',
				label: 'LMBC Status',
				value: lmbcStatusPreview(self, 1),
			},
		],
		callback: async (e) => {
			if (!self) return
			try {
				const arrayIndex = Number(e.options.array_index) || 1 // User-selected beam control array (1-4)
				const beamAngle = Math.max(10, Math.min(99, Number(e.options.beam_angle) || 15))
				const elementsPerOutput = Math.max(1, Math.min(2, Number(e.options.elements_per_output) || 1))
				const bypass = e.options.bypass === 'true' ? 'true' : 'false'
				const controlType = e.options.control_type === '1' ? '1' : '0'
				const numberOfElements = Math.max(8, Math.min(32, Number(e.options.number_of_elements) || 12))
				const startingOutput = Math.max(1, Math.min(NUM_OUTPUTS, Number(e.options.starting_output) || 1))
				const startingElement = Math.max(1, Math.min(32, Number(e.options.starting_element) || 1))

				// Product type mapping: 0:LEOM, 1:LYON, 2:LEOPARD, 3:MICA, 4:MELODIE, 5:MINA, 6:MILO, 7:M3D, 8:M2D, 9:PANTHER
				const productType = String(e.options.product_type || '0')

				const commands = [
					`/processing/beam_control_array/${arrayIndex}/beam_angle='${beamAngle}'`,
					`/processing/beam_control_array/${arrayIndex}/bypass='${bypass}'`,
					`/processing/beam_control_array/${arrayIndex}/control_type='${controlType}'`,
					`/processing/beam_control_array/${arrayIndex}/elements_per_output='${elementsPerOutput}'`,
					`/processing/beam_control_array/${arrayIndex}/number_of_elements='${numberOfElements}'`,
					`/processing/beam_control_array/${arrayIndex}/product_type='${productType}'`,
					`/processing/beam_control_array/${arrayIndex}/starting_output_number='${startingOutput}'`,
					`/processing/beam_control_array/${arrayIndex}/starting_element='${startingElement}'`,
				]

				// Send commands
				for (const cmd of commands) {
					self._cmdSendLine(cmd)
				}

				const productTypeLabels = {
					'0': 'LEO-M',
					'1': 'LYON',
					'2': 'LEOPARD',
					'3': 'MICA',
					'4': 'MELODIE',
					'5': 'MINA',
					'6': 'MILO',
					'7': 'M3D',
					'8': 'M2D',
					'9': 'PANTHER',
				}
				const speakerName = productTypeLabels[productType] || 'Unknown'
				const bypassStatus = bypass === 'true' ? 'Bypassed' : 'Active'
				const typeLabel = controlType === '1' ? 'Steer Up' : 'Spread'

				// Build log message with beam control status
				let logMessage = `LMBC: ${speakerName} | ${numberOfElements} elements (${elementsPerOutput}/output) | ${beamAngle}Â° ${typeLabel} | Output ${startingOutput} | ${bypassStatus}`

				// Add error status if available
				if (self.beamControlStatus && self.beamControlStatus[arrayIndex]) {
					const status = self.beamControlStatus[arrayIndex]
					if (status.errorCodeLabel) {
						logMessage += ` | Status: ${status.errorCodeLabel}`
					}
					if (status.errorString && status.errorString.trim() !== '') {
						logMessage += ` | ${status.errorString}`
					}
				}

				self.log?.('info', logMessage)
			} catch (err) {
				self.log?.('error', `LMBC configuration failed: ${err?.message || err}`)
			}
		},
	}

	// =========================
	// ===== REGISTER ALL ======
	// =========================
	self.setActionDefinitions(actions)
}
